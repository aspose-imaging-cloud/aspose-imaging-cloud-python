# coding: utf-8

"""
    Aspose.Imaging Cloud API Reference

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 3.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from asposeimagingcloud.api_client import ApiClient


class ImagingApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def copy_file(self, src_path, dest_path, **kwargs):  # noqa: E501
        """Copy file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_file(src_path, dest_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str src_path: Source file path e.g. '/folder/file.ext' (required)
        :param str dest_path: Destination file path (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :param str version_id: File version ID to copy
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.copy_file_with_http_info(src_path, dest_path, **kwargs)  # noqa: E501
        else:
            (data) = self.copy_file_with_http_info(src_path, dest_path, **kwargs)  # noqa: E501
            return data

    def copy_file_with_http_info(self, src_path, dest_path, **kwargs):  # noqa: E501
        """Copy file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_file_with_http_info(src_path, dest_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str src_path: Source file path e.g. '/folder/file.ext' (required)
        :param str dest_path: Destination file path (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :param str version_id: File version ID to copy
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'dest_path', 'src_storage_name', 'dest_storage_name', 'version_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params or
                params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `copy_file`")  # noqa: E501
        # verify the required parameter 'dest_path' is set
        if ('dest_path' not in params or
                params['dest_path'] is None):
            raise ValueError("Missing the required parameter `dest_path` when calling `copy_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'src_path' in params:
            path_params['srcPath'] = params['src_path']  # noqa: E501

        query_params = []
        if 'dest_path' in params:
            query_params.append(('destPath', params['dest_path']))  # noqa: E501
        if 'src_storage_name' in params:
            query_params.append(('srcStorageName', params['src_storage_name']))  # noqa: E501
        if 'dest_storage_name' in params:
            query_params.append(('destStorageName', params['dest_storage_name']))  # noqa: E501
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/file/copy/{srcPath}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def copy_folder(self, src_path, dest_path, **kwargs):  # noqa: E501
        """Copy folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_folder(src_path, dest_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str src_path: Source folder path e.g. '/src' (required)
        :param str dest_path: Destination folder path e.g. '/dst' (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.copy_folder_with_http_info(src_path, dest_path, **kwargs)  # noqa: E501
        else:
            (data) = self.copy_folder_with_http_info(src_path, dest_path, **kwargs)  # noqa: E501
            return data

    def copy_folder_with_http_info(self, src_path, dest_path, **kwargs):  # noqa: E501
        """Copy folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_folder_with_http_info(src_path, dest_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str src_path: Source folder path e.g. '/src' (required)
        :param str dest_path: Destination folder path e.g. '/dst' (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'dest_path', 'src_storage_name', 'dest_storage_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params or
                params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `copy_folder`")  # noqa: E501
        # verify the required parameter 'dest_path' is set
        if ('dest_path' not in params or
                params['dest_path'] is None):
            raise ValueError("Missing the required parameter `dest_path` when calling `copy_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'src_path' in params:
            path_params['srcPath'] = params['src_path']  # noqa: E501

        query_params = []
        if 'dest_path' in params:
            query_params.append(('destPath', params['dest_path']))  # noqa: E501
        if 'src_storage_name' in params:
            query_params.append(('srcStorageName', params['src_storage_name']))  # noqa: E501
        if 'dest_storage_name' in params:
            query_params.append(('destStorageName', params['dest_storage_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/folder/copy/{srcPath}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_folder(self, path, **kwargs):  # noqa: E501
        """Create the folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_folder(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: Folder path to create e.g. 'folder_1/folder_2/' (required)
        :param str storage_name: Storage name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_folder_with_http_info(path, **kwargs)  # noqa: E501
        else:
            (data) = self.create_folder_with_http_info(path, **kwargs)  # noqa: E501
            return data

    def create_folder_with_http_info(self, path, **kwargs):  # noqa: E501
        """Create the folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_folder_with_http_info(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: Folder path to create e.g. 'folder_1/folder_2/' (required)
        :param str storage_name: Storage name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `create_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/folder/{path}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_file(self, path, **kwargs):  # noqa: E501
        """Delete file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_file(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: File path e.g. '/folder/file.ext' (required)
        :param str storage_name: Storage name
        :param str version_id: File version ID to delete
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_file_with_http_info(path, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_file_with_http_info(path, **kwargs)  # noqa: E501
            return data

    def delete_file_with_http_info(self, path, **kwargs):  # noqa: E501
        """Delete file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_file_with_http_info(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: File path e.g. '/folder/file.ext' (required)
        :param str storage_name: Storage name
        :param str version_id: File version ID to delete
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name', 'version_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `delete_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))  # noqa: E501
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/file/{path}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_folder(self, path, **kwargs):  # noqa: E501
        """Delete folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_folder(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: Folder path e.g. '/folder' (required)
        :param str storage_name: Storage name
        :param bool recursive: Enable to delete folders, subfolders and files
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_folder_with_http_info(path, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_folder_with_http_info(path, **kwargs)  # noqa: E501
            return data

    def delete_folder_with_http_info(self, path, **kwargs):  # noqa: E501
        """Delete folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_folder_with_http_info(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: Folder path e.g. '/folder' (required)
        :param str storage_name: Storage name
        :param bool recursive: Enable to delete folders, subfolders and files
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name', 'recursive']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `delete_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))  # noqa: E501
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/folder/{path}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_search_context(self, search_context_id, **kwargs):  # noqa: E501
        """Deletes the search context.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_search_context(search_context_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_search_context_with_http_info(search_context_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_search_context_with_http_info(search_context_id, **kwargs)  # noqa: E501
            return data

    def delete_search_context_with_http_info(self, search_context_id, **kwargs):  # noqa: E501
        """Deletes the search context.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_search_context_with_http_info(search_context_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_search_context" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `delete_search_context`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_search_context_image(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Delete image and images features from search context  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_search_context_image(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: Search context identifier. (required)
        :param str image_id: Image identifier. (required)
        :param str folder: Folder.
        :param str storage: Storage
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_search_context_image_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_search_context_image_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
            return data

    def delete_search_context_image_with_http_info(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Delete image and images features from search context  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_search_context_image_with_http_info(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: Search context identifier. (required)
        :param str image_id: Image identifier. (required)
        :param str folder: Folder.
        :param str storage: Storage
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'image_id', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_search_context_image" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `delete_search_context_image`")  # noqa: E501
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params or
                params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `delete_search_context_image`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'image_id' in params:
            query_params.append(('imageId', params['image_id']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/image', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_search_context_image_features(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Deletes image features from search context.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_search_context_image_features(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str image_id: The image identifier. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_search_context_image_features_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_search_context_image_features_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
            return data

    def delete_search_context_image_features_with_http_info(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Deletes image features from search context.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_search_context_image_features_with_http_info(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str image_id: The image identifier. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'image_id', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_search_context_image_features" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `delete_search_context_image_features`")  # noqa: E501
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params or
                params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `delete_search_context_image_features`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'image_id' in params:
            query_params.append(('imageId', params['image_id']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/features', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_file(self, path, **kwargs):  # noqa: E501
        """Download file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_file(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: File path e.g. '/folder/file.ext' (required)
        :param str storage_name: Storage name
        :param str version_id: File version ID to download
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.download_file_with_http_info(path, **kwargs)  # noqa: E501
        else:
            (data) = self.download_file_with_http_info(path, **kwargs)  # noqa: E501
            return data

    def download_file_with_http_info(self, path, **kwargs):  # noqa: E501
        """Download file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_file_with_http_info(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: File path e.g. '/folder/file.ext' (required)
        :param str storage_name: Storage name
        :param str version_id: File version ID to download
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name', 'version_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `download_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))  # noqa: E501
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['multipart/form-data'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/file/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_disc_usage(self, **kwargs):  # noqa: E501
        """Get disc usage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_disc_usage(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str storage_name: Storage name
        :return: DiscUsage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_disc_usage_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_disc_usage_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_disc_usage_with_http_info(self, **kwargs):  # noqa: E501
        """Get disc usage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_disc_usage_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str storage_name: Storage name
        :return: DiscUsage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['storage_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_disc_usage" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/disc', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DiscUsage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_file_versions(self, path, **kwargs):  # noqa: E501
        """Get file versions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_versions(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: File path e.g. '/file.ext' (required)
        :param str storage_name: Storage name
        :return: FileVersions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_file_versions_with_http_info(path, **kwargs)  # noqa: E501
        else:
            (data) = self.get_file_versions_with_http_info(path, **kwargs)  # noqa: E501
            return data

    def get_file_versions_with_http_info(self, path, **kwargs):  # noqa: E501
        """Get file versions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_versions_with_http_info(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: File path e.g. '/file.ext' (required)
        :param str storage_name: Storage name
        :return: FileVersions
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_versions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `get_file_versions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/version/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileVersions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_files_list(self, path, **kwargs):  # noqa: E501
        """Get all files and folders within a folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_files_list(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: Folder path e.g. '/folder' (required)
        :param str storage_name: Storage name
        :return: FilesList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_files_list_with_http_info(path, **kwargs)  # noqa: E501
        else:
            (data) = self.get_files_list_with_http_info(path, **kwargs)  # noqa: E501
            return data

    def get_files_list_with_http_info(self, path, **kwargs):  # noqa: E501
        """Get all files and folders within a folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_files_list_with_http_info(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: Folder path e.g. '/folder' (required)
        :param str storage_name: Storage name
        :return: FilesList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_files_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `get_files_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/folder/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilesList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_bmp(self, name, bits_per_pixel, horizontal_resolution, vertical_resolution, **kwargs):  # noqa: E501
        """Update parameters of existing BMP image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_bmp(name, bits_per_pixel, horizontal_resolution, vertical_resolution, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param int bits_per_pixel: Color depth. (required)
        :param int horizontal_resolution: New horizontal resolution. (required)
        :param int vertical_resolution: New vertical resolution. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_bmp_with_http_info(name, bits_per_pixel, horizontal_resolution, vertical_resolution, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_bmp_with_http_info(name, bits_per_pixel, horizontal_resolution, vertical_resolution, **kwargs)  # noqa: E501
            return data

    def get_image_bmp_with_http_info(self, name, bits_per_pixel, horizontal_resolution, vertical_resolution, **kwargs):  # noqa: E501
        """Update parameters of existing BMP image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_bmp_with_http_info(name, bits_per_pixel, horizontal_resolution, vertical_resolution, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param int bits_per_pixel: Color depth. (required)
        :param int horizontal_resolution: New horizontal resolution. (required)
        :param int vertical_resolution: New vertical resolution. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'bits_per_pixel', 'horizontal_resolution', 'vertical_resolution', 'from_scratch', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_bmp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_bmp`")  # noqa: E501
        # verify the required parameter 'bits_per_pixel' is set
        if ('bits_per_pixel' not in params or
                params['bits_per_pixel'] is None):
            raise ValueError("Missing the required parameter `bits_per_pixel` when calling `get_image_bmp`")  # noqa: E501
        # verify the required parameter 'horizontal_resolution' is set
        if ('horizontal_resolution' not in params or
                params['horizontal_resolution'] is None):
            raise ValueError("Missing the required parameter `horizontal_resolution` when calling `get_image_bmp`")  # noqa: E501
        # verify the required parameter 'vertical_resolution' is set
        if ('vertical_resolution' not in params or
                params['vertical_resolution'] is None):
            raise ValueError("Missing the required parameter `vertical_resolution` when calling `get_image_bmp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'bits_per_pixel' in params:
            query_params.append(('bitsPerPixel', params['bits_per_pixel']))  # noqa: E501
        if 'horizontal_resolution' in params:
            query_params.append(('horizontalResolution', params['horizontal_resolution']))  # noqa: E501
        if 'vertical_resolution' in params:
            query_params.append(('verticalResolution', params['vertical_resolution']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/bmp', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_crop(self, name, format, x, y, width, height, **kwargs):  # noqa: E501
        """Crop an existing image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_crop(name, format, x, y, width, height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of an image. (required)
        :param str format: Resulting image format. (required)
        :param int x: X position of start point for cropping rectangle. (required)
        :param int y: Y position of start point for cropping rectangle. (required)
        :param int width: Width of cropping rectangle (required)
        :param int height: Height of cropping rectangle. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_crop_with_http_info(name, format, x, y, width, height, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_crop_with_http_info(name, format, x, y, width, height, **kwargs)  # noqa: E501
            return data

    def get_image_crop_with_http_info(self, name, format, x, y, width, height, **kwargs):  # noqa: E501
        """Crop an existing image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_crop_with_http_info(name, format, x, y, width, height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of an image. (required)
        :param str format: Resulting image format. (required)
        :param int x: X position of start point for cropping rectangle. (required)
        :param int y: Y position of start point for cropping rectangle. (required)
        :param int width: Width of cropping rectangle (required)
        :param int height: Height of cropping rectangle. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'format', 'x', 'y', 'width', 'height', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_crop" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_crop`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `get_image_crop`")  # noqa: E501
        # verify the required parameter 'x' is set
        if ('x' not in params or
                params['x'] is None):
            raise ValueError("Missing the required parameter `x` when calling `get_image_crop`")  # noqa: E501
        # verify the required parameter 'y' is set
        if ('y' not in params or
                params['y'] is None):
            raise ValueError("Missing the required parameter `y` when calling `get_image_crop`")  # noqa: E501
        # verify the required parameter 'width' is set
        if ('width' not in params or
                params['width'] is None):
            raise ValueError("Missing the required parameter `width` when calling `get_image_crop`")  # noqa: E501
        # verify the required parameter 'height' is set
        if ('height' not in params or
                params['height'] is None):
            raise ValueError("Missing the required parameter `height` when calling `get_image_crop`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'x' in params:
            query_params.append(('x', params['x']))  # noqa: E501
        if 'y' in params:
            query_params.append(('y', params['y']))  # noqa: E501
        if 'width' in params:
            query_params.append(('width', params['width']))  # noqa: E501
        if 'height' in params:
            query_params.append(('height', params['height']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/crop', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_emf(self, name, bk_color, page_width, page_height, border_x, border_y, **kwargs):  # noqa: E501
        """Process existing EMF imaging using given parameters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_emf(name, bk_color, page_width, page_height, border_x, border_y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str bk_color: Color of the background. (required)
        :param int page_width: Width of the page. (required)
        :param int page_height: Height of the page. (required)
        :param int border_x: Border width. (required)
        :param int border_y: Border height. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :param str format: Export format (PNG is the default one).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_emf_with_http_info(name, bk_color, page_width, page_height, border_x, border_y, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_emf_with_http_info(name, bk_color, page_width, page_height, border_x, border_y, **kwargs)  # noqa: E501
            return data

    def get_image_emf_with_http_info(self, name, bk_color, page_width, page_height, border_x, border_y, **kwargs):  # noqa: E501
        """Process existing EMF imaging using given parameters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_emf_with_http_info(name, bk_color, page_width, page_height, border_x, border_y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str bk_color: Color of the background. (required)
        :param int page_width: Width of the page. (required)
        :param int page_height: Height of the page. (required)
        :param int border_x: Border width. (required)
        :param int border_y: Border height. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :param str format: Export format (PNG is the default one).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'bk_color', 'page_width', 'page_height', 'border_x', 'border_y', 'from_scratch', 'out_path', 'folder', 'storage', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_emf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_emf`")  # noqa: E501
        # verify the required parameter 'bk_color' is set
        if ('bk_color' not in params or
                params['bk_color'] is None):
            raise ValueError("Missing the required parameter `bk_color` when calling `get_image_emf`")  # noqa: E501
        # verify the required parameter 'page_width' is set
        if ('page_width' not in params or
                params['page_width'] is None):
            raise ValueError("Missing the required parameter `page_width` when calling `get_image_emf`")  # noqa: E501
        # verify the required parameter 'page_height' is set
        if ('page_height' not in params or
                params['page_height'] is None):
            raise ValueError("Missing the required parameter `page_height` when calling `get_image_emf`")  # noqa: E501
        # verify the required parameter 'border_x' is set
        if ('border_x' not in params or
                params['border_x'] is None):
            raise ValueError("Missing the required parameter `border_x` when calling `get_image_emf`")  # noqa: E501
        # verify the required parameter 'border_y' is set
        if ('border_y' not in params or
                params['border_y'] is None):
            raise ValueError("Missing the required parameter `border_y` when calling `get_image_emf`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'bk_color' in params:
            query_params.append(('bkColor', params['bk_color']))  # noqa: E501
        if 'page_width' in params:
            query_params.append(('pageWidth', params['page_width']))  # noqa: E501
        if 'page_height' in params:
            query_params.append(('pageHeight', params['page_height']))  # noqa: E501
        if 'border_x' in params:
            query_params.append(('borderX', params['border_x']))  # noqa: E501
        if 'border_y' in params:
            query_params.append(('borderY', params['border_y']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/emf', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_frame(self, name, frame_id, **kwargs):  # noqa: E501
        """Get separate frame from existing TIFF image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_frame(name, frame_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param int frame_id: Number of a frame. (required)
        :param int new_width: New width.
        :param int new_height: New height.
        :param int x: X position of start point for cropping rectangle.
        :param int y: Y position of start point for cropping rectangle.
        :param int rect_width: Width of cropping rectangle.
        :param int rect_height: Height of cropping rectangle.
        :param str rotate_flip_method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). Default is RotateNoneFlipNone.
        :param bool save_other_frames: If result will include all other frames or just a specified frame.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_frame_with_http_info(name, frame_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_frame_with_http_info(name, frame_id, **kwargs)  # noqa: E501
            return data

    def get_image_frame_with_http_info(self, name, frame_id, **kwargs):  # noqa: E501
        """Get separate frame from existing TIFF image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_frame_with_http_info(name, frame_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param int frame_id: Number of a frame. (required)
        :param int new_width: New width.
        :param int new_height: New height.
        :param int x: X position of start point for cropping rectangle.
        :param int y: Y position of start point for cropping rectangle.
        :param int rect_width: Width of cropping rectangle.
        :param int rect_height: Height of cropping rectangle.
        :param str rotate_flip_method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). Default is RotateNoneFlipNone.
        :param bool save_other_frames: If result will include all other frames or just a specified frame.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'frame_id', 'new_width', 'new_height', 'x', 'y', 'rect_width', 'rect_height', 'rotate_flip_method', 'save_other_frames', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_frame" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_frame`")  # noqa: E501
        # verify the required parameter 'frame_id' is set
        if ('frame_id' not in params or
                params['frame_id'] is None):
            raise ValueError("Missing the required parameter `frame_id` when calling `get_image_frame`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'frame_id' in params:
            path_params['frameId'] = params['frame_id']  # noqa: E501

        query_params = []
        if 'new_width' in params:
            query_params.append(('newWidth', params['new_width']))  # noqa: E501
        if 'new_height' in params:
            query_params.append(('newHeight', params['new_height']))  # noqa: E501
        if 'x' in params:
            query_params.append(('x', params['x']))  # noqa: E501
        if 'y' in params:
            query_params.append(('y', params['y']))  # noqa: E501
        if 'rect_width' in params:
            query_params.append(('rectWidth', params['rect_width']))  # noqa: E501
        if 'rect_height' in params:
            query_params.append(('rectHeight', params['rect_height']))  # noqa: E501
        if 'rotate_flip_method' in params:
            query_params.append(('rotateFlipMethod', params['rotate_flip_method']))  # noqa: E501
        if 'save_other_frames' in params:
            query_params.append(('saveOtherFrames', params['save_other_frames']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/frames/{frameId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_frame_properties(self, name, frame_id, **kwargs):  # noqa: E501
        """Get separate frame properties of existing TIFF image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_frame_properties(name, frame_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename with image. (required)
        :param int frame_id: Number of a frame. (required)
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: ImagingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_frame_properties_with_http_info(name, frame_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_frame_properties_with_http_info(name, frame_id, **kwargs)  # noqa: E501
            return data

    def get_image_frame_properties_with_http_info(self, name, frame_id, **kwargs):  # noqa: E501
        """Get separate frame properties of existing TIFF image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_frame_properties_with_http_info(name, frame_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename with image. (required)
        :param int frame_id: Number of a frame. (required)
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: ImagingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'frame_id', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_frame_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_frame_properties`")  # noqa: E501
        # verify the required parameter 'frame_id' is set
        if ('frame_id' not in params or
                params['frame_id'] is None):
            raise ValueError("Missing the required parameter `frame_id` when calling `get_image_frame_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'frame_id' in params:
            path_params['frameId'] = params['frame_id']  # noqa: E501

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/frames/{frameId}/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImagingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_gif(self, name, **kwargs):  # noqa: E501
        """Update parameters of existing GIF image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_gif(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param int background_color_index: Index of the background color.
        :param int color_resolution: Color resolution.
        :param bool has_trailer: Specifies if image has trailer.
        :param bool interlaced: Specifies if image is interlaced.
        :param bool is_palette_sorted: Specifies if palette is sorted.
        :param int pixel_aspect_ratio: Pixel aspect ratio.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_gif_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_gif_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_image_gif_with_http_info(self, name, **kwargs):  # noqa: E501
        """Update parameters of existing GIF image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_gif_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param int background_color_index: Index of the background color.
        :param int color_resolution: Color resolution.
        :param bool has_trailer: Specifies if image has trailer.
        :param bool interlaced: Specifies if image is interlaced.
        :param bool is_palette_sorted: Specifies if palette is sorted.
        :param int pixel_aspect_ratio: Pixel aspect ratio.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'background_color_index', 'color_resolution', 'has_trailer', 'interlaced', 'is_palette_sorted', 'pixel_aspect_ratio', 'from_scratch', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_gif" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_gif`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'background_color_index' in params:
            query_params.append(('backgroundColorIndex', params['background_color_index']))  # noqa: E501
        if 'color_resolution' in params:
            query_params.append(('colorResolution', params['color_resolution']))  # noqa: E501
        if 'has_trailer' in params:
            query_params.append(('hasTrailer', params['has_trailer']))  # noqa: E501
        if 'interlaced' in params:
            query_params.append(('interlaced', params['interlaced']))  # noqa: E501
        if 'is_palette_sorted' in params:
            query_params.append(('isPaletteSorted', params['is_palette_sorted']))  # noqa: E501
        if 'pixel_aspect_ratio' in params:
            query_params.append(('pixelAspectRatio', params['pixel_aspect_ratio']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/gif', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_jpeg2000(self, name, comment, **kwargs):  # noqa: E501
        """Update parameters of existing JPEG2000 image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_jpeg2000(name, comment, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str comment: The comment. (required)
        :param str codec: The codec.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_jpeg2000_with_http_info(name, comment, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_jpeg2000_with_http_info(name, comment, **kwargs)  # noqa: E501
            return data

    def get_image_jpeg2000_with_http_info(self, name, comment, **kwargs):  # noqa: E501
        """Update parameters of existing JPEG2000 image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_jpeg2000_with_http_info(name, comment, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str comment: The comment. (required)
        :param str codec: The codec.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'comment', 'codec', 'from_scratch', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_jpeg2000" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_jpeg2000`")  # noqa: E501
        # verify the required parameter 'comment' is set
        if ('comment' not in params or
                params['comment'] is None):
            raise ValueError("Missing the required parameter `comment` when calling `get_image_jpeg2000`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'comment' in params:
            query_params.append(('comment', params['comment']))  # noqa: E501
        if 'codec' in params:
            query_params.append(('codec', params['codec']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/jpg2000', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_jpg(self, name, **kwargs):  # noqa: E501
        """Update parameters of existing JPEG image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_jpg(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param int quality: Quality of an image from 0 to 100. Default is 75.
        :param str compression_type: Compression type.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_jpg_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_jpg_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_image_jpg_with_http_info(self, name, **kwargs):  # noqa: E501
        """Update parameters of existing JPEG image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_jpg_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param int quality: Quality of an image from 0 to 100. Default is 75.
        :param str compression_type: Compression type.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'quality', 'compression_type', 'from_scratch', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_jpg" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_jpg`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'quality' in params:
            query_params.append(('quality', params['quality']))  # noqa: E501
        if 'compression_type' in params:
            query_params.append(('compressionType', params['compression_type']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/jpg', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_properties(self, name, **kwargs):  # noqa: E501
        """Get properties of an image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_properties(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of an image. (required)
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: ImagingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_properties_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_properties_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_image_properties_with_http_info(self, name, **kwargs):  # noqa: E501
        """Get properties of an image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_properties_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of an image. (required)
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: ImagingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImagingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_psd(self, name, **kwargs):  # noqa: E501
        """Update parameters of existing PSD image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_psd(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param int channels_count: Count of color channels.
        :param str compression_method: Compression method.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_psd_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_psd_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_image_psd_with_http_info(self, name, **kwargs):  # noqa: E501
        """Update parameters of existing PSD image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_psd_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param int channels_count: Count of color channels.
        :param str compression_method: Compression method.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'channels_count', 'compression_method', 'from_scratch', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_psd" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_psd`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'channels_count' in params:
            query_params.append(('channelsCount', params['channels_count']))  # noqa: E501
        if 'compression_method' in params:
            query_params.append(('compressionMethod', params['compression_method']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/psd', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_resize(self, name, format, new_width, new_height, **kwargs):  # noqa: E501
        """Resize an existing image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_resize(name, format, new_width, new_height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of an image. (required)
        :param str format: Resulting image format. (required)
        :param int new_width: New width. (required)
        :param int new_height: New height. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_resize_with_http_info(name, format, new_width, new_height, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_resize_with_http_info(name, format, new_width, new_height, **kwargs)  # noqa: E501
            return data

    def get_image_resize_with_http_info(self, name, format, new_width, new_height, **kwargs):  # noqa: E501
        """Resize an existing image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_resize_with_http_info(name, format, new_width, new_height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of an image. (required)
        :param str format: Resulting image format. (required)
        :param int new_width: New width. (required)
        :param int new_height: New height. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'format', 'new_width', 'new_height', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_resize" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_resize`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `get_image_resize`")  # noqa: E501
        # verify the required parameter 'new_width' is set
        if ('new_width' not in params or
                params['new_width'] is None):
            raise ValueError("Missing the required parameter `new_width` when calling `get_image_resize`")  # noqa: E501
        # verify the required parameter 'new_height' is set
        if ('new_height' not in params or
                params['new_height'] is None):
            raise ValueError("Missing the required parameter `new_height` when calling `get_image_resize`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'new_width' in params:
            query_params.append(('newWidth', params['new_width']))  # noqa: E501
        if 'new_height' in params:
            query_params.append(('newHeight', params['new_height']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/resize', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_rotate_flip(self, name, format, method, **kwargs):  # noqa: E501
        """Rotate and/or flip an existing image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_rotate_flip(name, format, method, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of an image. (required)
        :param str format: Resulting image format. (required)
        :param str method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_rotate_flip_with_http_info(name, format, method, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_rotate_flip_with_http_info(name, format, method, **kwargs)  # noqa: E501
            return data

    def get_image_rotate_flip_with_http_info(self, name, format, method, **kwargs):  # noqa: E501
        """Rotate and/or flip an existing image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_rotate_flip_with_http_info(name, format, method, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of an image. (required)
        :param str format: Resulting image format. (required)
        :param str method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'format', 'method', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_rotate_flip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_rotate_flip`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `get_image_rotate_flip`")  # noqa: E501
        # verify the required parameter 'method' is set
        if ('method' not in params or
                params['method'] is None):
            raise ValueError("Missing the required parameter `method` when calling `get_image_rotate_flip`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'method' in params:
            query_params.append(('method', params['method']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/rotateflip', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_save_as(self, name, format, **kwargs):  # noqa: E501
        """Export existing image to another format.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_save_as(name, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str format: Resulting image format. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_save_as_with_http_info(name, format, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_save_as_with_http_info(name, format, **kwargs)  # noqa: E501
            return data

    def get_image_save_as_with_http_info(self, name, format, **kwargs):  # noqa: E501
        """Export existing image to another format.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_save_as_with_http_info(name, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str format: Resulting image format. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'format', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_save_as" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_save_as`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `get_image_save_as`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/saveAs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_tiff(self, name, compression, resolution_unit, bit_depth, **kwargs):  # noqa: E501
        """Update parameters of existing TIFF image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_tiff(name, compression, resolution_unit, bit_depth, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str compression: Compression. (required)
        :param str resolution_unit: New resolution unit. (required)
        :param int bit_depth: Bit depth. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param float horizontal_resolution: New horizontal resolution.
        :param float vertical_resolution: New verstical resolution.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_tiff_with_http_info(name, compression, resolution_unit, bit_depth, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_tiff_with_http_info(name, compression, resolution_unit, bit_depth, **kwargs)  # noqa: E501
            return data

    def get_image_tiff_with_http_info(self, name, compression, resolution_unit, bit_depth, **kwargs):  # noqa: E501
        """Update parameters of existing TIFF image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_tiff_with_http_info(name, compression, resolution_unit, bit_depth, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str compression: Compression. (required)
        :param str resolution_unit: New resolution unit. (required)
        :param int bit_depth: Bit depth. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param float horizontal_resolution: New horizontal resolution.
        :param float vertical_resolution: New verstical resolution.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'compression', 'resolution_unit', 'bit_depth', 'from_scratch', 'horizontal_resolution', 'vertical_resolution', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_tiff" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_tiff`")  # noqa: E501
        # verify the required parameter 'compression' is set
        if ('compression' not in params or
                params['compression'] is None):
            raise ValueError("Missing the required parameter `compression` when calling `get_image_tiff`")  # noqa: E501
        # verify the required parameter 'resolution_unit' is set
        if ('resolution_unit' not in params or
                params['resolution_unit'] is None):
            raise ValueError("Missing the required parameter `resolution_unit` when calling `get_image_tiff`")  # noqa: E501
        # verify the required parameter 'bit_depth' is set
        if ('bit_depth' not in params or
                params['bit_depth'] is None):
            raise ValueError("Missing the required parameter `bit_depth` when calling `get_image_tiff`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'compression' in params:
            query_params.append(('compression', params['compression']))  # noqa: E501
        if 'resolution_unit' in params:
            query_params.append(('resolutionUnit', params['resolution_unit']))  # noqa: E501
        if 'bit_depth' in params:
            query_params.append(('bitDepth', params['bit_depth']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'horizontal_resolution' in params:
            query_params.append(('horizontalResolution', params['horizontal_resolution']))  # noqa: E501
        if 'vertical_resolution' in params:
            query_params.append(('verticalResolution', params['vertical_resolution']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/tiff', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_update(self, name, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, **kwargs):  # noqa: E501
        """Perform scaling, cropping and flipping of an existing image in a single request.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_update(name, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of an image. (required)
        :param str format: Resulting image format. (required)
        :param int new_width: New width of the scaled image. (required)
        :param int new_height: New height of the scaled image. (required)
        :param int x: X position of start point for cropping rectangle. (required)
        :param int y: Y position of start point for cropping rectangle. (required)
        :param int rect_width: Width of cropping rectangle. (required)
        :param int rect_height: Height of cropping rectangle. (required)
        :param str rotate_flip_method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). Default is RotateNoneFlipNone. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_update_with_http_info(name, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_update_with_http_info(name, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, **kwargs)  # noqa: E501
            return data

    def get_image_update_with_http_info(self, name, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, **kwargs):  # noqa: E501
        """Perform scaling, cropping and flipping of an existing image in a single request.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_update_with_http_info(name, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of an image. (required)
        :param str format: Resulting image format. (required)
        :param int new_width: New width of the scaled image. (required)
        :param int new_height: New height of the scaled image. (required)
        :param int x: X position of start point for cropping rectangle. (required)
        :param int y: Y position of start point for cropping rectangle. (required)
        :param int rect_width: Width of cropping rectangle. (required)
        :param int rect_height: Height of cropping rectangle. (required)
        :param str rotate_flip_method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). Default is RotateNoneFlipNone. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'format', 'new_width', 'new_height', 'x', 'y', 'rect_width', 'rect_height', 'rotate_flip_method', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_update`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `get_image_update`")  # noqa: E501
        # verify the required parameter 'new_width' is set
        if ('new_width' not in params or
                params['new_width'] is None):
            raise ValueError("Missing the required parameter `new_width` when calling `get_image_update`")  # noqa: E501
        # verify the required parameter 'new_height' is set
        if ('new_height' not in params or
                params['new_height'] is None):
            raise ValueError("Missing the required parameter `new_height` when calling `get_image_update`")  # noqa: E501
        # verify the required parameter 'x' is set
        if ('x' not in params or
                params['x'] is None):
            raise ValueError("Missing the required parameter `x` when calling `get_image_update`")  # noqa: E501
        # verify the required parameter 'y' is set
        if ('y' not in params or
                params['y'] is None):
            raise ValueError("Missing the required parameter `y` when calling `get_image_update`")  # noqa: E501
        # verify the required parameter 'rect_width' is set
        if ('rect_width' not in params or
                params['rect_width'] is None):
            raise ValueError("Missing the required parameter `rect_width` when calling `get_image_update`")  # noqa: E501
        # verify the required parameter 'rect_height' is set
        if ('rect_height' not in params or
                params['rect_height'] is None):
            raise ValueError("Missing the required parameter `rect_height` when calling `get_image_update`")  # noqa: E501
        # verify the required parameter 'rotate_flip_method' is set
        if ('rotate_flip_method' not in params or
                params['rotate_flip_method'] is None):
            raise ValueError("Missing the required parameter `rotate_flip_method` when calling `get_image_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'new_width' in params:
            query_params.append(('newWidth', params['new_width']))  # noqa: E501
        if 'new_height' in params:
            query_params.append(('newHeight', params['new_height']))  # noqa: E501
        if 'x' in params:
            query_params.append(('x', params['x']))  # noqa: E501
        if 'y' in params:
            query_params.append(('y', params['y']))  # noqa: E501
        if 'rect_width' in params:
            query_params.append(('rectWidth', params['rect_width']))  # noqa: E501
        if 'rect_height' in params:
            query_params.append(('rectHeight', params['rect_height']))  # noqa: E501
        if 'rotate_flip_method' in params:
            query_params.append(('rotateFlipMethod', params['rotate_flip_method']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/updateImage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_web_p(self, name, loss_less, quality, anim_loop_count, anim_background_color, **kwargs):  # noqa: E501
        """Update parameters of existing WEBP image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_web_p(name, loss_less, quality, anim_loop_count, anim_background_color, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param bool loss_less: If WEBP is lossless. (required)
        :param int quality: Quality. (required)
        :param int anim_loop_count: The animation loop count. (required)
        :param str anim_background_color: Color of the animation background. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_web_p_with_http_info(name, loss_less, quality, anim_loop_count, anim_background_color, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_web_p_with_http_info(name, loss_less, quality, anim_loop_count, anim_background_color, **kwargs)  # noqa: E501
            return data

    def get_image_web_p_with_http_info(self, name, loss_less, quality, anim_loop_count, anim_background_color, **kwargs):  # noqa: E501
        """Update parameters of existing WEBP image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_web_p_with_http_info(name, loss_less, quality, anim_loop_count, anim_background_color, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param bool loss_less: If WEBP is lossless. (required)
        :param int quality: Quality. (required)
        :param int anim_loop_count: The animation loop count. (required)
        :param str anim_background_color: Color of the animation background. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'loss_less', 'quality', 'anim_loop_count', 'anim_background_color', 'from_scratch', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_web_p" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_web_p`")  # noqa: E501
        # verify the required parameter 'loss_less' is set
        if ('loss_less' not in params or
                params['loss_less'] is None):
            raise ValueError("Missing the required parameter `loss_less` when calling `get_image_web_p`")  # noqa: E501
        # verify the required parameter 'quality' is set
        if ('quality' not in params or
                params['quality'] is None):
            raise ValueError("Missing the required parameter `quality` when calling `get_image_web_p`")  # noqa: E501
        # verify the required parameter 'anim_loop_count' is set
        if ('anim_loop_count' not in params or
                params['anim_loop_count'] is None):
            raise ValueError("Missing the required parameter `anim_loop_count` when calling `get_image_web_p`")  # noqa: E501
        # verify the required parameter 'anim_background_color' is set
        if ('anim_background_color' not in params or
                params['anim_background_color'] is None):
            raise ValueError("Missing the required parameter `anim_background_color` when calling `get_image_web_p`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'loss_less' in params:
            query_params.append(('lossLess', params['loss_less']))  # noqa: E501
        if 'quality' in params:
            query_params.append(('quality', params['quality']))  # noqa: E501
        if 'anim_loop_count' in params:
            query_params.append(('animLoopCount', params['anim_loop_count']))  # noqa: E501
        if 'anim_background_color' in params:
            query_params.append(('animBackgroundColor', params['anim_background_color']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/webp', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_wmf(self, name, bk_color, page_width, page_height, border_x, border_y, **kwargs):  # noqa: E501
        """Process existing WMF image using given parameters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_wmf(name, bk_color, page_width, page_height, border_x, border_y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str bk_color: Color of the background. (required)
        :param int page_width: Width of the page. (required)
        :param int page_height: Height of the page. (required)
        :param int border_x: Border width. (required)
        :param int border_y: Border height. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :param str format: Export format (PNG is the default one).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_wmf_with_http_info(name, bk_color, page_width, page_height, border_x, border_y, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_wmf_with_http_info(name, bk_color, page_width, page_height, border_x, border_y, **kwargs)  # noqa: E501
            return data

    def get_image_wmf_with_http_info(self, name, bk_color, page_width, page_height, border_x, border_y, **kwargs):  # noqa: E501
        """Process existing WMF image using given parameters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_wmf_with_http_info(name, bk_color, page_width, page_height, border_x, border_y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str bk_color: Color of the background. (required)
        :param int page_width: Width of the page. (required)
        :param int page_height: Height of the page. (required)
        :param int border_x: Border width. (required)
        :param int border_y: Border height. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :param str format: Export format (PNG is the default one).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'bk_color', 'page_width', 'page_height', 'border_x', 'border_y', 'from_scratch', 'out_path', 'folder', 'storage', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_wmf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_wmf`")  # noqa: E501
        # verify the required parameter 'bk_color' is set
        if ('bk_color' not in params or
                params['bk_color'] is None):
            raise ValueError("Missing the required parameter `bk_color` when calling `get_image_wmf`")  # noqa: E501
        # verify the required parameter 'page_width' is set
        if ('page_width' not in params or
                params['page_width'] is None):
            raise ValueError("Missing the required parameter `page_width` when calling `get_image_wmf`")  # noqa: E501
        # verify the required parameter 'page_height' is set
        if ('page_height' not in params or
                params['page_height'] is None):
            raise ValueError("Missing the required parameter `page_height` when calling `get_image_wmf`")  # noqa: E501
        # verify the required parameter 'border_x' is set
        if ('border_x' not in params or
                params['border_x'] is None):
            raise ValueError("Missing the required parameter `border_x` when calling `get_image_wmf`")  # noqa: E501
        # verify the required parameter 'border_y' is set
        if ('border_y' not in params or
                params['border_y'] is None):
            raise ValueError("Missing the required parameter `border_y` when calling `get_image_wmf`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'bk_color' in params:
            query_params.append(('bkColor', params['bk_color']))  # noqa: E501
        if 'page_width' in params:
            query_params.append(('pageWidth', params['page_width']))  # noqa: E501
        if 'page_height' in params:
            query_params.append(('pageHeight', params['page_height']))  # noqa: E501
        if 'border_x' in params:
            query_params.append(('borderX', params['border_x']))  # noqa: E501
        if 'border_y' in params:
            query_params.append(('borderY', params['border_y']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/wmf', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_search_context_extract_image_features(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Extract features from image without adding to search context. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_extract_image_features(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str image_id: The image identifier. (required)
        :param file image_data: Input image
        :param str folder: The folder.
        :param str storage: The storage.
        :return: ImageFeatures
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_search_context_extract_image_features_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_search_context_extract_image_features_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
            return data

    def get_search_context_extract_image_features_with_http_info(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Extract features from image without adding to search context. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_extract_image_features_with_http_info(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str image_id: The image identifier. (required)
        :param file image_data: Input image
        :param str folder: The folder.
        :param str storage: The storage.
        :return: ImageFeatures
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'image_id', 'image_data', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_search_context_extract_image_features" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `get_search_context_extract_image_features`")  # noqa: E501
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params or
                params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `get_search_context_extract_image_features`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'image_id' in params:
            query_params.append(('imageId', params['image_id']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/image2features', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImageFeatures',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_search_context_find_duplicates(self, search_context_id, similarity_threshold, **kwargs):  # noqa: E501
        """Find images duplicates.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_find_duplicates(search_context_id, similarity_threshold, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param float similarity_threshold: The similarity threshold. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: ImageDuplicatesSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_search_context_find_duplicates_with_http_info(search_context_id, similarity_threshold, **kwargs)  # noqa: E501
        else:
            (data) = self.get_search_context_find_duplicates_with_http_info(search_context_id, similarity_threshold, **kwargs)  # noqa: E501
            return data

    def get_search_context_find_duplicates_with_http_info(self, search_context_id, similarity_threshold, **kwargs):  # noqa: E501
        """Find images duplicates.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_find_duplicates_with_http_info(search_context_id, similarity_threshold, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param float similarity_threshold: The similarity threshold. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: ImageDuplicatesSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'similarity_threshold', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_search_context_find_duplicates" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `get_search_context_find_duplicates`")  # noqa: E501
        # verify the required parameter 'similarity_threshold' is set
        if ('similarity_threshold' not in params or
                params['similarity_threshold'] is None):
            raise ValueError("Missing the required parameter `similarity_threshold` when calling `get_search_context_find_duplicates`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'similarity_threshold' in params:
            query_params.append(('similarityThreshold', params['similarity_threshold']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/findDuplicates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImageDuplicatesSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_search_context_find_similar(self, search_context_id, similarity_threshold, max_count, **kwargs):  # noqa: E501
        """Find similar images. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_find_similar(search_context_id, similarity_threshold, max_count, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param float similarity_threshold: The similarity threshold. (required)
        :param int max_count: The maximum count. (required)
        :param file image_data: Input image
        :param str image_id: The search image identifier.
        :param str folder: The folder.
        :param str storage: The storage.
        :return: SearchResultsSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_search_context_find_similar_with_http_info(search_context_id, similarity_threshold, max_count, **kwargs)  # noqa: E501
        else:
            (data) = self.get_search_context_find_similar_with_http_info(search_context_id, similarity_threshold, max_count, **kwargs)  # noqa: E501
            return data

    def get_search_context_find_similar_with_http_info(self, search_context_id, similarity_threshold, max_count, **kwargs):  # noqa: E501
        """Find similar images. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_find_similar_with_http_info(search_context_id, similarity_threshold, max_count, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param float similarity_threshold: The similarity threshold. (required)
        :param int max_count: The maximum count. (required)
        :param file image_data: Input image
        :param str image_id: The search image identifier.
        :param str folder: The folder.
        :param str storage: The storage.
        :return: SearchResultsSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'similarity_threshold', 'max_count', 'image_data', 'image_id', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_search_context_find_similar" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `get_search_context_find_similar`")  # noqa: E501
        # verify the required parameter 'similarity_threshold' is set
        if ('similarity_threshold' not in params or
                params['similarity_threshold'] is None):
            raise ValueError("Missing the required parameter `similarity_threshold` when calling `get_search_context_find_similar`")  # noqa: E501
        # verify the required parameter 'max_count' is set
        if ('max_count' not in params or
                params['max_count'] is None):
            raise ValueError("Missing the required parameter `max_count` when calling `get_search_context_find_similar`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'similarity_threshold' in params:
            query_params.append(('similarityThreshold', params['similarity_threshold']))  # noqa: E501
        if 'max_count' in params:
            query_params.append(('maxCount', params['max_count']))  # noqa: E501
        if 'image_id' in params:
            query_params.append(('imageId', params['image_id']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/findSimilar', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchResultsSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_search_context_image(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Get image from search context  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_image(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: Search context identifier. (required)
        :param str image_id: Image identifier. (required)
        :param str folder: Folder.
        :param str storage: Storage
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_search_context_image_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_search_context_image_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
            return data

    def get_search_context_image_with_http_info(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Get image from search context  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_image_with_http_info(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: Search context identifier. (required)
        :param str image_id: Image identifier. (required)
        :param str folder: Folder.
        :param str storage: Storage
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'image_id', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_search_context_image" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `get_search_context_image`")  # noqa: E501
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params or
                params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `get_search_context_image`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'image_id' in params:
            query_params.append(('imageId', params['image_id']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/image', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_search_context_image_features(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Gets image features from search context.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_image_features(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str image_id: The image identifier. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: ImageFeatures
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_search_context_image_features_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_search_context_image_features_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
            return data

    def get_search_context_image_features_with_http_info(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Gets image features from search context.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_image_features_with_http_info(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str image_id: The image identifier. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: ImageFeatures
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'image_id', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_search_context_image_features" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `get_search_context_image_features`")  # noqa: E501
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params or
                params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `get_search_context_image_features`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'image_id' in params:
            query_params.append(('imageId', params['image_id']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/features', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImageFeatures',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_search_context_status(self, search_context_id, **kwargs):  # noqa: E501
        """Gets the search context status.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_status(search_context_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: SearchContextStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_search_context_status_with_http_info(search_context_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_search_context_status_with_http_info(search_context_id, **kwargs)  # noqa: E501
            return data

    def get_search_context_status_with_http_info(self, search_context_id, **kwargs):  # noqa: E501
        """Gets the search context status.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_status_with_http_info(search_context_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: SearchContextStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_search_context_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `get_search_context_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchContextStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tiff_to_fax(self, name, **kwargs):  # noqa: E501
        """Update parameters of existing TIFF image accordingly to fax parameters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tiff_to_fax(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str storage: Your Aspose Cloud Storage name.
        :param str folder: Folder with image to process.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_tiff_to_fax_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tiff_to_fax_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_tiff_to_fax_with_http_info(self, name, **kwargs):  # noqa: E501
        """Update parameters of existing TIFF image accordingly to fax parameters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tiff_to_fax_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str storage: Your Aspose Cloud Storage name.
        :param str folder: Folder with image to process.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder', 'out_path']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tiff_to_fax" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_tiff_to_fax`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/tiff/{name}/toFax', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def move_file(self, src_path, dest_path, **kwargs):  # noqa: E501
        """Move file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.move_file(src_path, dest_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str src_path: Source file path e.g. '/src.ext' (required)
        :param str dest_path: Destination file path e.g. '/dest.ext' (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :param str version_id: File version ID to move
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.move_file_with_http_info(src_path, dest_path, **kwargs)  # noqa: E501
        else:
            (data) = self.move_file_with_http_info(src_path, dest_path, **kwargs)  # noqa: E501
            return data

    def move_file_with_http_info(self, src_path, dest_path, **kwargs):  # noqa: E501
        """Move file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.move_file_with_http_info(src_path, dest_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str src_path: Source file path e.g. '/src.ext' (required)
        :param str dest_path: Destination file path e.g. '/dest.ext' (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :param str version_id: File version ID to move
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'dest_path', 'src_storage_name', 'dest_storage_name', 'version_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method move_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params or
                params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `move_file`")  # noqa: E501
        # verify the required parameter 'dest_path' is set
        if ('dest_path' not in params or
                params['dest_path'] is None):
            raise ValueError("Missing the required parameter `dest_path` when calling `move_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'src_path' in params:
            path_params['srcPath'] = params['src_path']  # noqa: E501

        query_params = []
        if 'dest_path' in params:
            query_params.append(('destPath', params['dest_path']))  # noqa: E501
        if 'src_storage_name' in params:
            query_params.append(('srcStorageName', params['src_storage_name']))  # noqa: E501
        if 'dest_storage_name' in params:
            query_params.append(('destStorageName', params['dest_storage_name']))  # noqa: E501
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/file/move/{srcPath}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def move_folder(self, src_path, dest_path, **kwargs):  # noqa: E501
        """Move folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.move_folder(src_path, dest_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str src_path: Folder path to move e.g. '/folder' (required)
        :param str dest_path: Destination folder path to move to e.g '/dst' (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.move_folder_with_http_info(src_path, dest_path, **kwargs)  # noqa: E501
        else:
            (data) = self.move_folder_with_http_info(src_path, dest_path, **kwargs)  # noqa: E501
            return data

    def move_folder_with_http_info(self, src_path, dest_path, **kwargs):  # noqa: E501
        """Move folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.move_folder_with_http_info(src_path, dest_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str src_path: Folder path to move e.g. '/folder' (required)
        :param str dest_path: Destination folder path to move to e.g '/dst' (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'dest_path', 'src_storage_name', 'dest_storage_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method move_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params or
                params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `move_folder`")  # noqa: E501
        # verify the required parameter 'dest_path' is set
        if ('dest_path' not in params or
                params['dest_path'] is None):
            raise ValueError("Missing the required parameter `dest_path` when calling `move_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'src_path' in params:
            path_params['srcPath'] = params['src_path']  # noqa: E501

        query_params = []
        if 'dest_path' in params:
            query_params.append(('destPath', params['dest_path']))  # noqa: E501
        if 'src_storage_name' in params:
            query_params.append(('srcStorageName', params['src_storage_name']))  # noqa: E501
        if 'dest_storage_name' in params:
            query_params.append(('destStorageName', params['dest_storage_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/folder/move/{srcPath}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def object_exists(self, path, **kwargs):  # noqa: E501
        """Check if file or folder exists  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.object_exists(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: File or folder path e.g. '/file.ext' or '/folder' (required)
        :param str storage_name: Storage name
        :param str version_id: File version ID
        :return: ObjectExist
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.object_exists_with_http_info(path, **kwargs)  # noqa: E501
        else:
            (data) = self.object_exists_with_http_info(path, **kwargs)  # noqa: E501
            return data

    def object_exists_with_http_info(self, path, **kwargs):  # noqa: E501
        """Check if file or folder exists  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.object_exists_with_http_info(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: File or folder path e.g. '/file.ext' or '/folder' (required)
        :param str storage_name: Storage name
        :param str version_id: File version ID
        :return: ObjectExist
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name', 'version_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method object_exists" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `object_exists`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))  # noqa: E501
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/exist/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ObjectExist',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_create_search_context(self, **kwargs):  # noqa: E501
        """Create new search context.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_create_search_context(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str detector: The image features detector.
        :param str matching_algorithm: The matching algorithm.
        :param str folder: The folder.
        :param str storage: The storage.
        :return: SearchContextStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_create_search_context_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_create_search_context_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_create_search_context_with_http_info(self, **kwargs):  # noqa: E501
        """Create new search context.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_create_search_context_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str detector: The image features detector.
        :param str matching_algorithm: The matching algorithm.
        :param str folder: The folder.
        :param str storage: The storage.
        :return: SearchContextStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['detector', 'matching_algorithm', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_create_search_context" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'detector' in params:
            query_params.append(('detector', params['detector']))  # noqa: E501
        if 'matching_algorithm' in params:
            query_params.append(('matchingAlgorithm', params['matching_algorithm']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchContextStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_bmp(self, image_data, bits_per_pixel, horizontal_resolution, vertical_resolution, **kwargs):  # noqa: E501
        """Update parameters of BMP image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_bmp(image_data, bits_per_pixel, horizontal_resolution, vertical_resolution, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int bits_per_pixel: Color depth. (required)
        :param int horizontal_resolution: New horizontal resolution. (required)
        :param int vertical_resolution: New vertical resolution. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_bmp_with_http_info(image_data, bits_per_pixel, horizontal_resolution, vertical_resolution, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_bmp_with_http_info(image_data, bits_per_pixel, horizontal_resolution, vertical_resolution, **kwargs)  # noqa: E501
            return data

    def post_image_bmp_with_http_info(self, image_data, bits_per_pixel, horizontal_resolution, vertical_resolution, **kwargs):  # noqa: E501
        """Update parameters of BMP image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_bmp_with_http_info(image_data, bits_per_pixel, horizontal_resolution, vertical_resolution, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int bits_per_pixel: Color depth. (required)
        :param int horizontal_resolution: New horizontal resolution. (required)
        :param int vertical_resolution: New vertical resolution. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'bits_per_pixel', 'horizontal_resolution', 'vertical_resolution', 'from_scratch', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_bmp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_bmp`")  # noqa: E501
        # verify the required parameter 'bits_per_pixel' is set
        if ('bits_per_pixel' not in params or
                params['bits_per_pixel'] is None):
            raise ValueError("Missing the required parameter `bits_per_pixel` when calling `post_image_bmp`")  # noqa: E501
        # verify the required parameter 'horizontal_resolution' is set
        if ('horizontal_resolution' not in params or
                params['horizontal_resolution'] is None):
            raise ValueError("Missing the required parameter `horizontal_resolution` when calling `post_image_bmp`")  # noqa: E501
        # verify the required parameter 'vertical_resolution' is set
        if ('vertical_resolution' not in params or
                params['vertical_resolution'] is None):
            raise ValueError("Missing the required parameter `vertical_resolution` when calling `post_image_bmp`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'bits_per_pixel' in params:
            query_params.append(('bitsPerPixel', params['bits_per_pixel']))  # noqa: E501
        if 'horizontal_resolution' in params:
            query_params.append(('horizontalResolution', params['horizontal_resolution']))  # noqa: E501
        if 'vertical_resolution' in params:
            query_params.append(('verticalResolution', params['vertical_resolution']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/bmp', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_crop(self, image_data, format, x, y, width, height, **kwargs):  # noqa: E501
        """Crop an image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_crop(image_data, format, x, y, width, height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str format: Resulting image format. (required)
        :param int x: X position of start point for cropping rectangle. (required)
        :param int y: Y position of start point for cropping rectangle. (required)
        :param int width: Width of cropping rectangle. (required)
        :param int height: Height of cropping rectangle. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_crop_with_http_info(image_data, format, x, y, width, height, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_crop_with_http_info(image_data, format, x, y, width, height, **kwargs)  # noqa: E501
            return data

    def post_image_crop_with_http_info(self, image_data, format, x, y, width, height, **kwargs):  # noqa: E501
        """Crop an image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_crop_with_http_info(image_data, format, x, y, width, height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str format: Resulting image format. (required)
        :param int x: X position of start point for cropping rectangle. (required)
        :param int y: Y position of start point for cropping rectangle. (required)
        :param int width: Width of cropping rectangle. (required)
        :param int height: Height of cropping rectangle. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'format', 'x', 'y', 'width', 'height', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_crop" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_crop`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `post_image_crop`")  # noqa: E501
        # verify the required parameter 'x' is set
        if ('x' not in params or
                params['x'] is None):
            raise ValueError("Missing the required parameter `x` when calling `post_image_crop`")  # noqa: E501
        # verify the required parameter 'y' is set
        if ('y' not in params or
                params['y'] is None):
            raise ValueError("Missing the required parameter `y` when calling `post_image_crop`")  # noqa: E501
        # verify the required parameter 'width' is set
        if ('width' not in params or
                params['width'] is None):
            raise ValueError("Missing the required parameter `width` when calling `post_image_crop`")  # noqa: E501
        # verify the required parameter 'height' is set
        if ('height' not in params or
                params['height'] is None):
            raise ValueError("Missing the required parameter `height` when calling `post_image_crop`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'x' in params:
            query_params.append(('x', params['x']))  # noqa: E501
        if 'y' in params:
            query_params.append(('y', params['y']))  # noqa: E501
        if 'width' in params:
            query_params.append(('width', params['width']))  # noqa: E501
        if 'height' in params:
            query_params.append(('height', params['height']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/crop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_emf(self, image_data, bk_color, page_width, page_height, border_x, border_y, **kwargs):  # noqa: E501
        """Process existing EMF imaging using given parameters. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_emf(image_data, bk_color, page_width, page_height, border_x, border_y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str bk_color: Color of the background. (required)
        :param int page_width: Width of the page. (required)
        :param int page_height: Height of the page. (required)
        :param int border_x: Border width. (required)
        :param int border_y: Border height. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :param str format: Export format (PNG is the default one).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_emf_with_http_info(image_data, bk_color, page_width, page_height, border_x, border_y, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_emf_with_http_info(image_data, bk_color, page_width, page_height, border_x, border_y, **kwargs)  # noqa: E501
            return data

    def post_image_emf_with_http_info(self, image_data, bk_color, page_width, page_height, border_x, border_y, **kwargs):  # noqa: E501
        """Process existing EMF imaging using given parameters. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_emf_with_http_info(image_data, bk_color, page_width, page_height, border_x, border_y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str bk_color: Color of the background. (required)
        :param int page_width: Width of the page. (required)
        :param int page_height: Height of the page. (required)
        :param int border_x: Border width. (required)
        :param int border_y: Border height. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :param str format: Export format (PNG is the default one).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'bk_color', 'page_width', 'page_height', 'border_x', 'border_y', 'from_scratch', 'out_path', 'storage', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_emf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_emf`")  # noqa: E501
        # verify the required parameter 'bk_color' is set
        if ('bk_color' not in params or
                params['bk_color'] is None):
            raise ValueError("Missing the required parameter `bk_color` when calling `post_image_emf`")  # noqa: E501
        # verify the required parameter 'page_width' is set
        if ('page_width' not in params or
                params['page_width'] is None):
            raise ValueError("Missing the required parameter `page_width` when calling `post_image_emf`")  # noqa: E501
        # verify the required parameter 'page_height' is set
        if ('page_height' not in params or
                params['page_height'] is None):
            raise ValueError("Missing the required parameter `page_height` when calling `post_image_emf`")  # noqa: E501
        # verify the required parameter 'border_x' is set
        if ('border_x' not in params or
                params['border_x'] is None):
            raise ValueError("Missing the required parameter `border_x` when calling `post_image_emf`")  # noqa: E501
        # verify the required parameter 'border_y' is set
        if ('border_y' not in params or
                params['border_y'] is None):
            raise ValueError("Missing the required parameter `border_y` when calling `post_image_emf`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'bk_color' in params:
            query_params.append(('bkColor', params['bk_color']))  # noqa: E501
        if 'page_width' in params:
            query_params.append(('pageWidth', params['page_width']))  # noqa: E501
        if 'page_height' in params:
            query_params.append(('pageHeight', params['page_height']))  # noqa: E501
        if 'border_x' in params:
            query_params.append(('borderX', params['border_x']))  # noqa: E501
        if 'border_y' in params:
            query_params.append(('borderY', params['border_y']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/emf', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_frame(self, image_data, frame_id, **kwargs):  # noqa: E501
        """Get separate frame from existing TIFF image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_frame(image_data, frame_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int frame_id: Number of a frame. (required)
        :param int new_width: New width.
        :param int new_height: New height.
        :param int x: X position of start point for cropping rectangle.
        :param int y: Y position of start point for cropping rectangle.
        :param int rect_width: Width of cropping rectangle.
        :param int rect_height: Height of cropping rectangle.
        :param str rotate_flip_method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). Default is RotateNoneFlipNone.
        :param bool save_other_frames: If result will include all other frames or just a specified frame.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_frame_with_http_info(image_data, frame_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_frame_with_http_info(image_data, frame_id, **kwargs)  # noqa: E501
            return data

    def post_image_frame_with_http_info(self, image_data, frame_id, **kwargs):  # noqa: E501
        """Get separate frame from existing TIFF image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_frame_with_http_info(image_data, frame_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int frame_id: Number of a frame. (required)
        :param int new_width: New width.
        :param int new_height: New height.
        :param int x: X position of start point for cropping rectangle.
        :param int y: Y position of start point for cropping rectangle.
        :param int rect_width: Width of cropping rectangle.
        :param int rect_height: Height of cropping rectangle.
        :param str rotate_flip_method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). Default is RotateNoneFlipNone.
        :param bool save_other_frames: If result will include all other frames or just a specified frame.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'frame_id', 'new_width', 'new_height', 'x', 'y', 'rect_width', 'rect_height', 'rotate_flip_method', 'save_other_frames', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_frame" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_frame`")  # noqa: E501
        # verify the required parameter 'frame_id' is set
        if ('frame_id' not in params or
                params['frame_id'] is None):
            raise ValueError("Missing the required parameter `frame_id` when calling `post_image_frame`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'frame_id' in params:
            path_params['frameId'] = params['frame_id']  # noqa: E501

        query_params = []
        if 'new_width' in params:
            query_params.append(('newWidth', params['new_width']))  # noqa: E501
        if 'new_height' in params:
            query_params.append(('newHeight', params['new_height']))  # noqa: E501
        if 'x' in params:
            query_params.append(('x', params['x']))  # noqa: E501
        if 'y' in params:
            query_params.append(('y', params['y']))  # noqa: E501
        if 'rect_width' in params:
            query_params.append(('rectWidth', params['rect_width']))  # noqa: E501
        if 'rect_height' in params:
            query_params.append(('rectHeight', params['rect_height']))  # noqa: E501
        if 'rotate_flip_method' in params:
            query_params.append(('rotateFlipMethod', params['rotate_flip_method']))  # noqa: E501
        if 'save_other_frames' in params:
            query_params.append(('saveOtherFrames', params['save_other_frames']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/frames/{frameId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_frame_properties(self, image_data, frame_id, **kwargs):  # noqa: E501
        """Get separate frame properties of existing TIFF image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_frame_properties(image_data, frame_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int frame_id: Number of a frame. (required)
        :return: ImagingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_frame_properties_with_http_info(image_data, frame_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_frame_properties_with_http_info(image_data, frame_id, **kwargs)  # noqa: E501
            return data

    def post_image_frame_properties_with_http_info(self, image_data, frame_id, **kwargs):  # noqa: E501
        """Get separate frame properties of existing TIFF image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_frame_properties_with_http_info(image_data, frame_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int frame_id: Number of a frame. (required)
        :return: ImagingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'frame_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_frame_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_frame_properties`")  # noqa: E501
        # verify the required parameter 'frame_id' is set
        if ('frame_id' not in params or
                params['frame_id'] is None):
            raise ValueError("Missing the required parameter `frame_id` when calling `post_image_frame_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'frame_id' in params:
            path_params['frameId'] = params['frame_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/frames/{frameId}/properties', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImagingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_gif(self, image_data, **kwargs):  # noqa: E501
        """Update parameters of GIF image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_gif(image_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int background_color_index: Index of the background color.
        :param int color_resolution: Color resolution.
        :param bool has_trailer: Specifies if image has trailer.
        :param bool interlaced: Specifies if image is interlaced.
        :param bool is_palette_sorted: Specifies if palette is sorted.
        :param int pixel_aspect_ratio: Pixel aspect ratio.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_gif_with_http_info(image_data, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_gif_with_http_info(image_data, **kwargs)  # noqa: E501
            return data

    def post_image_gif_with_http_info(self, image_data, **kwargs):  # noqa: E501
        """Update parameters of GIF image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_gif_with_http_info(image_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int background_color_index: Index of the background color.
        :param int color_resolution: Color resolution.
        :param bool has_trailer: Specifies if image has trailer.
        :param bool interlaced: Specifies if image is interlaced.
        :param bool is_palette_sorted: Specifies if palette is sorted.
        :param int pixel_aspect_ratio: Pixel aspect ratio.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'background_color_index', 'color_resolution', 'has_trailer', 'interlaced', 'is_palette_sorted', 'pixel_aspect_ratio', 'from_scratch', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_gif" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_gif`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'background_color_index' in params:
            query_params.append(('backgroundColorIndex', params['background_color_index']))  # noqa: E501
        if 'color_resolution' in params:
            query_params.append(('colorResolution', params['color_resolution']))  # noqa: E501
        if 'has_trailer' in params:
            query_params.append(('hasTrailer', params['has_trailer']))  # noqa: E501
        if 'interlaced' in params:
            query_params.append(('interlaced', params['interlaced']))  # noqa: E501
        if 'is_palette_sorted' in params:
            query_params.append(('isPaletteSorted', params['is_palette_sorted']))  # noqa: E501
        if 'pixel_aspect_ratio' in params:
            query_params.append(('pixelAspectRatio', params['pixel_aspect_ratio']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/gif', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_jpeg2000(self, image_data, comment, **kwargs):  # noqa: E501
        """Update parameters of JPEG2000 image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_jpeg2000(image_data, comment, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str comment: The comment. (required)
        :param str codec: The codec.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_jpeg2000_with_http_info(image_data, comment, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_jpeg2000_with_http_info(image_data, comment, **kwargs)  # noqa: E501
            return data

    def post_image_jpeg2000_with_http_info(self, image_data, comment, **kwargs):  # noqa: E501
        """Update parameters of JPEG2000 image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_jpeg2000_with_http_info(image_data, comment, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str comment: The comment. (required)
        :param str codec: The codec.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'comment', 'codec', 'from_scratch', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_jpeg2000" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_jpeg2000`")  # noqa: E501
        # verify the required parameter 'comment' is set
        if ('comment' not in params or
                params['comment'] is None):
            raise ValueError("Missing the required parameter `comment` when calling `post_image_jpeg2000`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'comment' in params:
            query_params.append(('comment', params['comment']))  # noqa: E501
        if 'codec' in params:
            query_params.append(('codec', params['codec']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/jpg2000', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_jpg(self, image_data, **kwargs):  # noqa: E501
        """Update parameters of JPEG image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_jpg(image_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int quality: Quality of an image from 0 to 100. Default is 75.
        :param str compression_type: Compression type.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_jpg_with_http_info(image_data, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_jpg_with_http_info(image_data, **kwargs)  # noqa: E501
            return data

    def post_image_jpg_with_http_info(self, image_data, **kwargs):  # noqa: E501
        """Update parameters of JPEG image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_jpg_with_http_info(image_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int quality: Quality of an image from 0 to 100. Default is 75.
        :param str compression_type: Compression type.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'quality', 'compression_type', 'from_scratch', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_jpg" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_jpg`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'quality' in params:
            query_params.append(('quality', params['quality']))  # noqa: E501
        if 'compression_type' in params:
            query_params.append(('compressionType', params['compression_type']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/jpg', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_properties(self, image_data, **kwargs):  # noqa: E501
        """Get properties of an image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_properties(image_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :return: ImagingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_properties_with_http_info(image_data, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_properties_with_http_info(image_data, **kwargs)  # noqa: E501
            return data

    def post_image_properties_with_http_info(self, image_data, **kwargs):  # noqa: E501
        """Get properties of an image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_properties_with_http_info(image_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :return: ImagingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        # TODO: Why codegen want to set Content-Type to application/json, if we are sending file?
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/properties', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImagingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_psd(self, image_data, **kwargs):  # noqa: E501
        """Update parameters of PSD image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_psd(image_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int channels_count: Count of color channels.
        :param str compression_method: Compression method.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_psd_with_http_info(image_data, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_psd_with_http_info(image_data, **kwargs)  # noqa: E501
            return data

    def post_image_psd_with_http_info(self, image_data, **kwargs):  # noqa: E501
        """Update parameters of PSD image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_psd_with_http_info(image_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int channels_count: Count of color channels.
        :param str compression_method: Compression method.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'channels_count', 'compression_method', 'from_scratch', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_psd" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_psd`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'channels_count' in params:
            query_params.append(('channelsCount', params['channels_count']))  # noqa: E501
        if 'compression_method' in params:
            query_params.append(('compressionMethod', params['compression_method']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/psd', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_resize(self, image_data, format, new_width, new_height, **kwargs):  # noqa: E501
        """Resize an image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_resize(image_data, format, new_width, new_height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str format: Resulting image format. (required)
        :param int new_width: New width. (required)
        :param int new_height: New height. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_resize_with_http_info(image_data, format, new_width, new_height, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_resize_with_http_info(image_data, format, new_width, new_height, **kwargs)  # noqa: E501
            return data

    def post_image_resize_with_http_info(self, image_data, format, new_width, new_height, **kwargs):  # noqa: E501
        """Resize an image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_resize_with_http_info(image_data, format, new_width, new_height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str format: Resulting image format. (required)
        :param int new_width: New width. (required)
        :param int new_height: New height. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'format', 'new_width', 'new_height', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_resize" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_resize`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `post_image_resize`")  # noqa: E501
        # verify the required parameter 'new_width' is set
        if ('new_width' not in params or
                params['new_width'] is None):
            raise ValueError("Missing the required parameter `new_width` when calling `post_image_resize`")  # noqa: E501
        # verify the required parameter 'new_height' is set
        if ('new_height' not in params or
                params['new_height'] is None):
            raise ValueError("Missing the required parameter `new_height` when calling `post_image_resize`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'new_width' in params:
            query_params.append(('newWidth', params['new_width']))  # noqa: E501
        if 'new_height' in params:
            query_params.append(('newHeight', params['new_height']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/resize', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_rotate_flip(self, image_data, format, method, **kwargs):  # noqa: E501
        """Rotate and/or flip an image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_rotate_flip(image_data, format, method, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str format: Resulting image format. (required)
        :param str method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_rotate_flip_with_http_info(image_data, format, method, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_rotate_flip_with_http_info(image_data, format, method, **kwargs)  # noqa: E501
            return data

    def post_image_rotate_flip_with_http_info(self, image_data, format, method, **kwargs):  # noqa: E501
        """Rotate and/or flip an image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_rotate_flip_with_http_info(image_data, format, method, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str format: Resulting image format. (required)
        :param str method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'format', 'method', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_rotate_flip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_rotate_flip`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `post_image_rotate_flip`")  # noqa: E501
        # verify the required parameter 'method' is set
        if ('method' not in params or
                params['method'] is None):
            raise ValueError("Missing the required parameter `method` when calling `post_image_rotate_flip`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'method' in params:
            query_params.append(('method', params['method']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/rotateflip', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_save_as(self, image_data, format, **kwargs):  # noqa: E501
        """Export existing image to another format. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.               # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_save_as(image_data, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str format: Resulting image format. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_save_as_with_http_info(image_data, format, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_save_as_with_http_info(image_data, format, **kwargs)  # noqa: E501
            return data

    def post_image_save_as_with_http_info(self, image_data, format, **kwargs):  # noqa: E501
        """Export existing image to another format. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.               # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_save_as_with_http_info(image_data, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str format: Resulting image format. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'format', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_save_as" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_save_as`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `post_image_save_as`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/saveAs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_tiff(self, image_data, compression, resolution_unit, bit_depth, **kwargs):  # noqa: E501
        """Update parameters of TIFF image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_tiff(image_data, compression, resolution_unit, bit_depth, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str compression: Compression. (required)
        :param str resolution_unit: New resolution unit. (required)
        :param int bit_depth: Bit depth. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param float horizontal_resolution: New horizontal resolution.
        :param float vertical_resolution: New verstical resolution.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_tiff_with_http_info(image_data, compression, resolution_unit, bit_depth, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_tiff_with_http_info(image_data, compression, resolution_unit, bit_depth, **kwargs)  # noqa: E501
            return data

    def post_image_tiff_with_http_info(self, image_data, compression, resolution_unit, bit_depth, **kwargs):  # noqa: E501
        """Update parameters of TIFF image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_tiff_with_http_info(image_data, compression, resolution_unit, bit_depth, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str compression: Compression. (required)
        :param str resolution_unit: New resolution unit. (required)
        :param int bit_depth: Bit depth. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param float horizontal_resolution: New horizontal resolution.
        :param float vertical_resolution: New verstical resolution.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'compression', 'resolution_unit', 'bit_depth', 'from_scratch', 'horizontal_resolution', 'vertical_resolution', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_tiff" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_tiff`")  # noqa: E501
        # verify the required parameter 'compression' is set
        if ('compression' not in params or
                params['compression'] is None):
            raise ValueError("Missing the required parameter `compression` when calling `post_image_tiff`")  # noqa: E501
        # verify the required parameter 'resolution_unit' is set
        if ('resolution_unit' not in params or
                params['resolution_unit'] is None):
            raise ValueError("Missing the required parameter `resolution_unit` when calling `post_image_tiff`")  # noqa: E501
        # verify the required parameter 'bit_depth' is set
        if ('bit_depth' not in params or
                params['bit_depth'] is None):
            raise ValueError("Missing the required parameter `bit_depth` when calling `post_image_tiff`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'compression' in params:
            query_params.append(('compression', params['compression']))  # noqa: E501
        if 'resolution_unit' in params:
            query_params.append(('resolutionUnit', params['resolution_unit']))  # noqa: E501
        if 'bit_depth' in params:
            query_params.append(('bitDepth', params['bit_depth']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'horizontal_resolution' in params:
            query_params.append(('horizontalResolution', params['horizontal_resolution']))  # noqa: E501
        if 'vertical_resolution' in params:
            query_params.append(('verticalResolution', params['vertical_resolution']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/tiff', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_update(self, image_data, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, **kwargs):  # noqa: E501
        """Perform scaling, cropping and flipping of an image in a single request. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.               # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_update(image_data, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str format: Resulting image format. (required)
        :param int new_width: New width of the scaled image. (required)
        :param int new_height: New height of the scaled image. (required)
        :param int x: X position of start point for cropping rectangle. (required)
        :param int y: Y position of start point for cropping rectangle. (required)
        :param int rect_width: Width of cropping rectangle. (required)
        :param int rect_height: Height of cropping rectangle. (required)
        :param str rotate_flip_method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). Default is RotateNoneFlipNone. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_update_with_http_info(image_data, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_update_with_http_info(image_data, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, **kwargs)  # noqa: E501
            return data

    def post_image_update_with_http_info(self, image_data, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, **kwargs):  # noqa: E501
        """Perform scaling, cropping and flipping of an image in a single request. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.               # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_update_with_http_info(image_data, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str format: Resulting image format. (required)
        :param int new_width: New width of the scaled image. (required)
        :param int new_height: New height of the scaled image. (required)
        :param int x: X position of start point for cropping rectangle. (required)
        :param int y: Y position of start point for cropping rectangle. (required)
        :param int rect_width: Width of cropping rectangle. (required)
        :param int rect_height: Height of cropping rectangle. (required)
        :param str rotate_flip_method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). Default is RotateNoneFlipNone. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'format', 'new_width', 'new_height', 'x', 'y', 'rect_width', 'rect_height', 'rotate_flip_method', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_update`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `post_image_update`")  # noqa: E501
        # verify the required parameter 'new_width' is set
        if ('new_width' not in params or
                params['new_width'] is None):
            raise ValueError("Missing the required parameter `new_width` when calling `post_image_update`")  # noqa: E501
        # verify the required parameter 'new_height' is set
        if ('new_height' not in params or
                params['new_height'] is None):
            raise ValueError("Missing the required parameter `new_height` when calling `post_image_update`")  # noqa: E501
        # verify the required parameter 'x' is set
        if ('x' not in params or
                params['x'] is None):
            raise ValueError("Missing the required parameter `x` when calling `post_image_update`")  # noqa: E501
        # verify the required parameter 'y' is set
        if ('y' not in params or
                params['y'] is None):
            raise ValueError("Missing the required parameter `y` when calling `post_image_update`")  # noqa: E501
        # verify the required parameter 'rect_width' is set
        if ('rect_width' not in params or
                params['rect_width'] is None):
            raise ValueError("Missing the required parameter `rect_width` when calling `post_image_update`")  # noqa: E501
        # verify the required parameter 'rect_height' is set
        if ('rect_height' not in params or
                params['rect_height'] is None):
            raise ValueError("Missing the required parameter `rect_height` when calling `post_image_update`")  # noqa: E501
        # verify the required parameter 'rotate_flip_method' is set
        if ('rotate_flip_method' not in params or
                params['rotate_flip_method'] is None):
            raise ValueError("Missing the required parameter `rotate_flip_method` when calling `post_image_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'new_width' in params:
            query_params.append(('newWidth', params['new_width']))  # noqa: E501
        if 'new_height' in params:
            query_params.append(('newHeight', params['new_height']))  # noqa: E501
        if 'x' in params:
            query_params.append(('x', params['x']))  # noqa: E501
        if 'y' in params:
            query_params.append(('y', params['y']))  # noqa: E501
        if 'rect_width' in params:
            query_params.append(('rectWidth', params['rect_width']))  # noqa: E501
        if 'rect_height' in params:
            query_params.append(('rectHeight', params['rect_height']))  # noqa: E501
        if 'rotate_flip_method' in params:
            query_params.append(('rotateFlipMethod', params['rotate_flip_method']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/updateImage', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_web_p(self, image_data, loss_less, quality, anim_loop_count, anim_background_color, **kwargs):  # noqa: E501
        """Update parameters of WEBP image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_web_p(image_data, loss_less, quality, anim_loop_count, anim_background_color, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param bool loss_less: If WEBP is lossless. (required)
        :param int quality: Quality. (required)
        :param int anim_loop_count: The animation loop count. (required)
        :param str anim_background_color: Color of the animation background. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_web_p_with_http_info(image_data, loss_less, quality, anim_loop_count, anim_background_color, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_web_p_with_http_info(image_data, loss_less, quality, anim_loop_count, anim_background_color, **kwargs)  # noqa: E501
            return data

    def post_image_web_p_with_http_info(self, image_data, loss_less, quality, anim_loop_count, anim_background_color, **kwargs):  # noqa: E501
        """Update parameters of WEBP image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_web_p_with_http_info(image_data, loss_less, quality, anim_loop_count, anim_background_color, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param bool loss_less: If WEBP is lossless. (required)
        :param int quality: Quality. (required)
        :param int anim_loop_count: The animation loop count. (required)
        :param str anim_background_color: Color of the animation background. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'loss_less', 'quality', 'anim_loop_count', 'anim_background_color', 'from_scratch', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_web_p" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_web_p`")  # noqa: E501
        # verify the required parameter 'loss_less' is set
        if ('loss_less' not in params or
                params['loss_less'] is None):
            raise ValueError("Missing the required parameter `loss_less` when calling `post_image_web_p`")  # noqa: E501
        # verify the required parameter 'quality' is set
        if ('quality' not in params or
                params['quality'] is None):
            raise ValueError("Missing the required parameter `quality` when calling `post_image_web_p`")  # noqa: E501
        # verify the required parameter 'anim_loop_count' is set
        if ('anim_loop_count' not in params or
                params['anim_loop_count'] is None):
            raise ValueError("Missing the required parameter `anim_loop_count` when calling `post_image_web_p`")  # noqa: E501
        # verify the required parameter 'anim_background_color' is set
        if ('anim_background_color' not in params or
                params['anim_background_color'] is None):
            raise ValueError("Missing the required parameter `anim_background_color` when calling `post_image_web_p`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'loss_less' in params:
            query_params.append(('lossLess', params['loss_less']))  # noqa: E501
        if 'quality' in params:
            query_params.append(('quality', params['quality']))  # noqa: E501
        if 'anim_loop_count' in params:
            query_params.append(('animLoopCount', params['anim_loop_count']))  # noqa: E501
        if 'anim_background_color' in params:
            query_params.append(('animBackgroundColor', params['anim_background_color']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/webp', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_wmf(self, image_data, bk_color, page_width, page_height, border_x, border_y, **kwargs):  # noqa: E501
        """Process existing WMF image using given parameters. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_wmf(image_data, bk_color, page_width, page_height, border_x, border_y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str bk_color: Color of the background. (required)
        :param int page_width: Width of the page. (required)
        :param int page_height: Height of the page. (required)
        :param int border_x: Border width. (required)
        :param int border_y: Border height. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :param str format: Export format (PNG is the default one).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_wmf_with_http_info(image_data, bk_color, page_width, page_height, border_x, border_y, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_wmf_with_http_info(image_data, bk_color, page_width, page_height, border_x, border_y, **kwargs)  # noqa: E501
            return data

    def post_image_wmf_with_http_info(self, image_data, bk_color, page_width, page_height, border_x, border_y, **kwargs):  # noqa: E501
        """Process existing WMF image using given parameters. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_wmf_with_http_info(image_data, bk_color, page_width, page_height, border_x, border_y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str bk_color: Color of the background. (required)
        :param int page_width: Width of the page. (required)
        :param int page_height: Height of the page. (required)
        :param int border_x: Border width. (required)
        :param int border_y: Border height. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true  they will be taken from default values for standard image, if it is false  they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :param str format: Export format (PNG is the default one).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'bk_color', 'page_width', 'page_height', 'border_x', 'border_y', 'from_scratch', 'out_path', 'storage', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_wmf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_wmf`")  # noqa: E501
        # verify the required parameter 'bk_color' is set
        if ('bk_color' not in params or
                params['bk_color'] is None):
            raise ValueError("Missing the required parameter `bk_color` when calling `post_image_wmf`")  # noqa: E501
        # verify the required parameter 'page_width' is set
        if ('page_width' not in params or
                params['page_width'] is None):
            raise ValueError("Missing the required parameter `page_width` when calling `post_image_wmf`")  # noqa: E501
        # verify the required parameter 'page_height' is set
        if ('page_height' not in params or
                params['page_height'] is None):
            raise ValueError("Missing the required parameter `page_height` when calling `post_image_wmf`")  # noqa: E501
        # verify the required parameter 'border_x' is set
        if ('border_x' not in params or
                params['border_x'] is None):
            raise ValueError("Missing the required parameter `border_x` when calling `post_image_wmf`")  # noqa: E501
        # verify the required parameter 'border_y' is set
        if ('border_y' not in params or
                params['border_y'] is None):
            raise ValueError("Missing the required parameter `border_y` when calling `post_image_wmf`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'bk_color' in params:
            query_params.append(('bkColor', params['bk_color']))  # noqa: E501
        if 'page_width' in params:
            query_params.append(('pageWidth', params['page_width']))  # noqa: E501
        if 'page_height' in params:
            query_params.append(('pageHeight', params['page_height']))  # noqa: E501
        if 'border_x' in params:
            query_params.append(('borderX', params['border_x']))  # noqa: E501
        if 'border_y' in params:
            query_params.append(('borderY', params['border_y']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/wmf', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_search_context_add_image(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Add image and images features to search context. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_search_context_add_image(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: Search context identifier. (required)
        :param str image_id: Image identifier. (required)
        :param file image_data: Input image
        :param str folder: Folder.
        :param str storage: Storage
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_search_context_add_image_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_search_context_add_image_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
            return data

    def post_search_context_add_image_with_http_info(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Add image and images features to search context. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_search_context_add_image_with_http_info(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: Search context identifier. (required)
        :param str image_id: Image identifier. (required)
        :param file image_data: Input image
        :param str folder: Folder.
        :param str storage: Storage
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'image_id', 'image_data', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_search_context_add_image" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `post_search_context_add_image`")  # noqa: E501
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params or
                params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `post_search_context_add_image`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'image_id' in params:
            query_params.append(('imageId', params['image_id']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/image', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_search_context_add_tag(self, image_data, search_context_id, tag_name, **kwargs):  # noqa: E501
        """Add tag and reference image to search context. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_search_context_add_tag(image_data, search_context_id, tag_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str search_context_id: The search context identifier. (required)
        :param str tag_name: The tag. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_search_context_add_tag_with_http_info(image_data, search_context_id, tag_name, **kwargs)  # noqa: E501
        else:
            (data) = self.post_search_context_add_tag_with_http_info(image_data, search_context_id, tag_name, **kwargs)  # noqa: E501
            return data

    def post_search_context_add_tag_with_http_info(self, image_data, search_context_id, tag_name, **kwargs):  # noqa: E501
        """Add tag and reference image to search context. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_search_context_add_tag_with_http_info(image_data, search_context_id, tag_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str search_context_id: The search context identifier. (required)
        :param str tag_name: The tag. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'search_context_id', 'tag_name', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_search_context_add_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_search_context_add_tag`")  # noqa: E501
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `post_search_context_add_tag`")  # noqa: E501
        # verify the required parameter 'tag_name' is set
        if ('tag_name' not in params or
                params['tag_name'] is None):
            raise ValueError("Missing the required parameter `tag_name` when calling `post_search_context_add_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'tag_name' in params:
            query_params.append(('tagName', params['tag_name']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/addTag', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_search_context_compare_images(self, search_context_id, image_id1, **kwargs):  # noqa: E501
        """Compare two images. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_search_context_compare_images(search_context_id, image_id1, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str image_id1: The first image Id in storage. (required)
        :param file image_data: Input image
        :param str image_id2: The second image Idin storage or null(if image loading in request).
        :param str folder: The folder.
        :param str storage: The storage.
        :return: SearchResultsSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_search_context_compare_images_with_http_info(search_context_id, image_id1, **kwargs)  # noqa: E501
        else:
            (data) = self.post_search_context_compare_images_with_http_info(search_context_id, image_id1, **kwargs)  # noqa: E501
            return data

    def post_search_context_compare_images_with_http_info(self, search_context_id, image_id1, **kwargs):  # noqa: E501
        """Compare two images. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_search_context_compare_images_with_http_info(search_context_id, image_id1, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str image_id1: The first image Id in storage. (required)
        :param file image_data: Input image
        :param str image_id2: The second image Idin storage or null(if image loading in request).
        :param str folder: The folder.
        :param str storage: The storage.
        :return: SearchResultsSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'image_id1', 'image_data', 'image_id2', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_search_context_compare_images" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `post_search_context_compare_images`")  # noqa: E501
        # verify the required parameter 'image_id1' is set
        if ('image_id1' not in params or
                params['image_id1'] is None):
            raise ValueError("Missing the required parameter `image_id1` when calling `post_search_context_compare_images`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'image_id1' in params:
            query_params.append(('imageId1', params['image_id1']))  # noqa: E501
        if 'image_id2' in params:
            query_params.append(('imageId2', params['image_id2']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/compare', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchResultsSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_search_context_extract_image_features(self, search_context_id, **kwargs):  # noqa: E501
        """Extract images features and add them to search context. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_search_context_extract_image_features(search_context_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param file image_data: Input image
        :param str image_id: The image identifier.
        :param str images_folder: Images folder.
        :param str folder: The folder.
        :param str storage: The storage.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_search_context_extract_image_features_with_http_info(search_context_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_search_context_extract_image_features_with_http_info(search_context_id, **kwargs)  # noqa: E501
            return data

    def post_search_context_extract_image_features_with_http_info(self, search_context_id, **kwargs):  # noqa: E501
        """Extract images features and add them to search context. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_search_context_extract_image_features_with_http_info(search_context_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param file image_data: Input image
        :param str image_id: The image identifier.
        :param str images_folder: Images folder.
        :param str folder: The folder.
        :param str storage: The storage.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'image_data', 'image_id', 'images_folder', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_search_context_extract_image_features" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `post_search_context_extract_image_features`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'image_id' in params:
            query_params.append(('imageId', params['image_id']))  # noqa: E501
        if 'images_folder' in params:
            query_params.append(('imagesFolder', params['images_folder']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/features', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_search_context_find_by_tags(self, tags, search_context_id, similarity_threshold, max_count, **kwargs):  # noqa: E501
        """Find images by tags. Tags JSON string is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_search_context_find_by_tags(tags, search_context_id, similarity_threshold, max_count, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tags: Tags array for searching (required)
        :param str search_context_id: The search context identifier. (required)
        :param float similarity_threshold: The similarity threshold. (required)
        :param int max_count: The maximum count. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: SearchResultsSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_search_context_find_by_tags_with_http_info(tags, search_context_id, similarity_threshold, max_count, **kwargs)  # noqa: E501
        else:
            (data) = self.post_search_context_find_by_tags_with_http_info(tags, search_context_id, similarity_threshold, max_count, **kwargs)  # noqa: E501
            return data

    def post_search_context_find_by_tags_with_http_info(self, tags, search_context_id, similarity_threshold, max_count, **kwargs):  # noqa: E501
        """Find images by tags. Tags JSON string is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_search_context_find_by_tags_with_http_info(tags, search_context_id, similarity_threshold, max_count, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tags: Tags array for searching (required)
        :param str search_context_id: The search context identifier. (required)
        :param float similarity_threshold: The similarity threshold. (required)
        :param int max_count: The maximum count. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: SearchResultsSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tags', 'search_context_id', 'similarity_threshold', 'max_count', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_search_context_find_by_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tags' is set
        if ('tags' not in params or
                params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `post_search_context_find_by_tags`")  # noqa: E501
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `post_search_context_find_by_tags`")  # noqa: E501
        # verify the required parameter 'similarity_threshold' is set
        if ('similarity_threshold' not in params or
                params['similarity_threshold'] is None):
            raise ValueError("Missing the required parameter `similarity_threshold` when calling `post_search_context_find_by_tags`")  # noqa: E501
        # verify the required parameter 'max_count' is set
        if ('max_count' not in params or
                params['max_count'] is None):
            raise ValueError("Missing the required parameter `max_count` when calling `post_search_context_find_by_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'similarity_threshold' in params:
            query_params.append(('similarityThreshold', params['similarity_threshold']))  # noqa: E501
        if 'max_count' in params:
            query_params.append(('maxCount', params['max_count']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'tags' in params:
            form_params.append(('tags', params['tags']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/findByTags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchResultsSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_tiff_append(self, name, append_file, **kwargs):  # noqa: E501
        """Appends existing TIFF image to another existing TIFF image (i.e. merges TIFF images).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_tiff_append(name, append_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Original image file name. (required)
        :param str append_file: Image file name to be appended to original one. (required)
        :param str storage: Your Aspose Cloud Storage name.
        :param str folder: Folder with images to process.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_tiff_append_with_http_info(name, append_file, **kwargs)  # noqa: E501
        else:
            (data) = self.post_tiff_append_with_http_info(name, append_file, **kwargs)  # noqa: E501
            return data

    def post_tiff_append_with_http_info(self, name, append_file, **kwargs):  # noqa: E501
        """Appends existing TIFF image to another existing TIFF image (i.e. merges TIFF images).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_tiff_append_with_http_info(name, append_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Original image file name. (required)
        :param str append_file: Image file name to be appended to original one. (required)
        :param str storage: Your Aspose Cloud Storage name.
        :param str folder: Folder with images to process.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'append_file', 'storage', 'folder']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_tiff_append" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_tiff_append`")  # noqa: E501
        # verify the required parameter 'append_file' is set
        if ('append_file' not in params or
                params['append_file'] is None):
            raise ValueError("Missing the required parameter `append_file` when calling `post_tiff_append`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'append_file' in params:
            query_params.append(('appendFile', params['append_file']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/tiff/{name}/appendTiff', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_search_context_image(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Update image and images features in search context. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_search_context_image(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: Search context identifier. (required)
        :param str image_id: Image identifier. (required)
        :param file image_data: Input image
        :param str folder: Folder.
        :param str storage: Storage
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_search_context_image_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
        else:
            (data) = self.put_search_context_image_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
            return data

    def put_search_context_image_with_http_info(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Update image and images features in search context. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_search_context_image_with_http_info(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: Search context identifier. (required)
        :param str image_id: Image identifier. (required)
        :param file image_data: Input image
        :param str folder: Folder.
        :param str storage: Storage
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'image_id', 'image_data', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_search_context_image" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `put_search_context_image`")  # noqa: E501
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params or
                params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `put_search_context_image`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'image_id' in params:
            query_params.append(('imageId', params['image_id']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/image', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_search_context_image_features(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Update images features in search context. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_search_context_image_features(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str image_id: The image identifier. (required)
        :param file image_data: Input image
        :param str folder: The folder.
        :param str storage: The storage.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_search_context_image_features_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
        else:
            (data) = self.put_search_context_image_features_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
            return data

    def put_search_context_image_features_with_http_info(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Update images features in search context. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_search_context_image_features_with_http_info(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str image_id: The image identifier. (required)
        :param file image_data: Input image
        :param str folder: The folder.
        :param str storage: The storage.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'image_id', 'image_data', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_search_context_image_features" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `put_search_context_image_features`")  # noqa: E501
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params or
                params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `put_search_context_image_features`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'image_id' in params:
            query_params.append(('imageId', params['image_id']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/features', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def storage_exists(self, storage_name, **kwargs):  # noqa: E501
        """Check if storage exists  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.storage_exists(storage_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str storage_name: Storage name (required)
        :return: StorageExist
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.storage_exists_with_http_info(storage_name, **kwargs)  # noqa: E501
        else:
            (data) = self.storage_exists_with_http_info(storage_name, **kwargs)  # noqa: E501
            return data

    def storage_exists_with_http_info(self, storage_name, **kwargs):  # noqa: E501
        """Check if storage exists  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.storage_exists_with_http_info(storage_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str storage_name: Storage name (required)
        :return: StorageExist
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['storage_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_exists" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'storage_name' is set
        if ('storage_name' not in params or
                params['storage_name'] is None):
            raise ValueError("Missing the required parameter `storage_name` when calling `storage_exists`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'storage_name' in params:
            path_params['storageName'] = params['storage_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/{storageName}/exist', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StorageExist',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_file(self, path, file, **kwargs):  # noqa: E501
        """Upload file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_file(path, file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext             If the content is multipart and path does not contains the file name it tries to get them from filename parameter             from Content-Disposition header.              (required)
        :param file file: File to upload (required)
        :param str storage_name: Storage name
        :return: FilesUploadResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_file_with_http_info(path, file, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_file_with_http_info(path, file, **kwargs)  # noqa: E501
            return data

    def upload_file_with_http_info(self, path, file, **kwargs):  # noqa: E501
        """Upload file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_file_with_http_info(path, file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext             If the content is multipart and path does not contains the file name it tries to get them from filename parameter             from Content-Disposition header.              (required)
        :param file file: File to upload (required)
        :param str storage_name: Storage name
        :return: FilesUploadResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'file', 'storage_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `upload_file`")  # noqa: E501
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `upload_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['File'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/file/{path}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilesUploadResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    # TODO: investigate auth algorithm
    def request_token(self):
        config = self.api_client.configuration
        request_url = "/connect/token"
        form_params = [('grant_type', 'client_credentials'), ('client_id', config.api_key['app_sid']),
                       ('client_secret', config.api_key['api_key'])]

        header_params = {'Accept': 'application/json', 'Content-Type': 'application/x-www-form-urlencoded'}

        api_version = self.api_client.configuration.api_version
        self.api_client.configuration.api_version = ''

        data = self.api_client.call_api(request_url, 'POST',
                                        {},
                                        [],
                                        header_params,
                                        post_params=form_params,
                                        response_type='object',
                                        files={}, _return_http_data_only=True)
        access_token = data['access_token'] if six.PY3 else data['access_token'].encode('utf8')
        self.api_client.configuration.access_token = access_token

        self.api_client.configuration.api_version = api_version
