# coding: utf-8

"""
    Aspose.Imaging Cloud API Reference

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 3.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from asposeimagingcloud.api_client import ApiClient


class ImagingApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def copy_file(self, src_path, dest_path, **kwargs):  # noqa: E501
        """Copy file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_file(src_path, dest_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str src_path: Source file path e.g. '/folder/file.ext' (required)
        :param str dest_path: Destination file path (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :param str version_id: File version ID to copy
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.copy_file_with_http_info(src_path, dest_path, **kwargs)  # noqa: E501
        else:
            (data) = self.copy_file_with_http_info(src_path, dest_path, **kwargs)  # noqa: E501
            return data

    def copy_file_with_http_info(self, src_path, dest_path, **kwargs):  # noqa: E501
        """Copy file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_file_with_http_info(src_path, dest_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str src_path: Source file path e.g. '/folder/file.ext' (required)
        :param str dest_path: Destination file path (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :param str version_id: File version ID to copy
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'dest_path', 'src_storage_name', 'dest_storage_name', 'version_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params or
                params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `copy_file`")  # noqa: E501
        # verify the required parameter 'dest_path' is set
        if ('dest_path' not in params or
                params['dest_path'] is None):
            raise ValueError("Missing the required parameter `dest_path` when calling `copy_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'src_path' in params:
            path_params['srcPath'] = params['src_path']  # noqa: E501

        query_params = []
        if 'dest_path' in params:
            query_params.append(('destPath', params['dest_path']))  # noqa: E501
        if 'src_storage_name' in params:
            query_params.append(('srcStorageName', params['src_storage_name']))  # noqa: E501
        if 'dest_storage_name' in params:
            query_params.append(('destStorageName', params['dest_storage_name']))  # noqa: E501
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/file/copy/{srcPath}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def copy_folder(self, src_path, dest_path, **kwargs):  # noqa: E501
        """Copy folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_folder(src_path, dest_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str src_path: Source folder path e.g. '/src' (required)
        :param str dest_path: Destination folder path e.g. '/dst' (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.copy_folder_with_http_info(src_path, dest_path, **kwargs)  # noqa: E501
        else:
            (data) = self.copy_folder_with_http_info(src_path, dest_path, **kwargs)  # noqa: E501
            return data

    def copy_folder_with_http_info(self, src_path, dest_path, **kwargs):  # noqa: E501
        """Copy folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_folder_with_http_info(src_path, dest_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str src_path: Source folder path e.g. '/src' (required)
        :param str dest_path: Destination folder path e.g. '/dst' (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'dest_path', 'src_storage_name', 'dest_storage_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params or
                params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `copy_folder`")  # noqa: E501
        # verify the required parameter 'dest_path' is set
        if ('dest_path' not in params or
                params['dest_path'] is None):
            raise ValueError("Missing the required parameter `dest_path` when calling `copy_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'src_path' in params:
            path_params['srcPath'] = params['src_path']  # noqa: E501

        query_params = []
        if 'dest_path' in params:
            query_params.append(('destPath', params['dest_path']))  # noqa: E501
        if 'src_storage_name' in params:
            query_params.append(('srcStorageName', params['src_storage_name']))  # noqa: E501
        if 'dest_storage_name' in params:
            query_params.append(('destStorageName', params['dest_storage_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/folder/copy/{srcPath}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_folder(self, path, **kwargs):  # noqa: E501
        """Create the folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_folder(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: Folder path to create e.g. 'folder_1/folder_2/' (required)
        :param str storage_name: Storage name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_folder_with_http_info(path, **kwargs)  # noqa: E501
        else:
            (data) = self.create_folder_with_http_info(path, **kwargs)  # noqa: E501
            return data

    def create_folder_with_http_info(self, path, **kwargs):  # noqa: E501
        """Create the folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_folder_with_http_info(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: Folder path to create e.g. 'folder_1/folder_2/' (required)
        :param str storage_name: Storage name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `create_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/folder/{path}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_file(self, path, **kwargs):  # noqa: E501
        """Delete file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_file(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: File path e.g. '/folder/file.ext' (required)
        :param str storage_name: Storage name
        :param str version_id: File version ID to delete
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_file_with_http_info(path, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_file_with_http_info(path, **kwargs)  # noqa: E501
            return data

    def delete_file_with_http_info(self, path, **kwargs):  # noqa: E501
        """Delete file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_file_with_http_info(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: File path e.g. '/folder/file.ext' (required)
        :param str storage_name: Storage name
        :param str version_id: File version ID to delete
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name', 'version_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `delete_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))  # noqa: E501
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/file/{path}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_folder(self, path, **kwargs):  # noqa: E501
        """Delete folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_folder(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: Folder path e.g. '/folder' (required)
        :param str storage_name: Storage name
        :param bool recursive: Enable to delete folders, subfolders and files
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_folder_with_http_info(path, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_folder_with_http_info(path, **kwargs)  # noqa: E501
            return data

    def delete_folder_with_http_info(self, path, **kwargs):  # noqa: E501
        """Delete folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_folder_with_http_info(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: Folder path e.g. '/folder' (required)
        :param str storage_name: Storage name
        :param bool recursive: Enable to delete folders, subfolders and files
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name', 'recursive']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `delete_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))  # noqa: E501
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/folder/{path}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_search_context(self, search_context_id, **kwargs):  # noqa: E501
        """Deletes the search context.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_search_context(search_context_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_search_context_with_http_info(search_context_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_search_context_with_http_info(search_context_id, **kwargs)  # noqa: E501
            return data

    def delete_search_context_with_http_info(self, search_context_id, **kwargs):  # noqa: E501
        """Deletes the search context.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_search_context_with_http_info(search_context_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_search_context" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `delete_search_context`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_search_context_image(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Delete image and images features from search context  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_search_context_image(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: Search context identifier. (required)
        :param str image_id: Image identifier. (required)
        :param str folder: Folder.
        :param str storage: Storage
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_search_context_image_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_search_context_image_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
            return data

    def delete_search_context_image_with_http_info(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Delete image and images features from search context  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_search_context_image_with_http_info(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: Search context identifier. (required)
        :param str image_id: Image identifier. (required)
        :param str folder: Folder.
        :param str storage: Storage
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'image_id', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_search_context_image" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `delete_search_context_image`")  # noqa: E501
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params or
                params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `delete_search_context_image`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'image_id' in params:
            query_params.append(('imageId', params['image_id']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/image', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_search_context_image_features(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Deletes image features from search context.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_search_context_image_features(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str image_id: The image identifier. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_search_context_image_features_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_search_context_image_features_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
            return data

    def delete_search_context_image_features_with_http_info(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Deletes image features from search context.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_search_context_image_features_with_http_info(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str image_id: The image identifier. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'image_id', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_search_context_image_features" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `delete_search_context_image_features`")  # noqa: E501
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params or
                params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `delete_search_context_image_features`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'image_id' in params:
            query_params.append(('imageId', params['image_id']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/features', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_file(self, path, **kwargs):  # noqa: E501
        """Download file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_file(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: File path e.g. '/folder/file.ext' (required)
        :param str storage_name: Storage name
        :param str version_id: File version ID to download
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.download_file_with_http_info(path, **kwargs)  # noqa: E501
        else:
            (data) = self.download_file_with_http_info(path, **kwargs)  # noqa: E501
            return data

    def download_file_with_http_info(self, path, **kwargs):  # noqa: E501
        """Download file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_file_with_http_info(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: File path e.g. '/folder/file.ext' (required)
        :param str storage_name: Storage name
        :param str version_id: File version ID to download
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name', 'version_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `download_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))  # noqa: E501
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['multipart/form-data'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/file/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_disc_usage(self, **kwargs):  # noqa: E501
        """Get disc usage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_disc_usage(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str storage_name: Storage name
        :return: DiscUsage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_disc_usage_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_disc_usage_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_disc_usage_with_http_info(self, **kwargs):  # noqa: E501
        """Get disc usage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_disc_usage_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str storage_name: Storage name
        :return: DiscUsage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['storage_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_disc_usage" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/disc', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DiscUsage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_file_versions(self, path, **kwargs):  # noqa: E501
        """Get file versions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_versions(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: File path e.g. '/file.ext' (required)
        :param str storage_name: Storage name
        :return: FileVersions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_file_versions_with_http_info(path, **kwargs)  # noqa: E501
        else:
            (data) = self.get_file_versions_with_http_info(path, **kwargs)  # noqa: E501
            return data

    def get_file_versions_with_http_info(self, path, **kwargs):  # noqa: E501
        """Get file versions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_versions_with_http_info(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: File path e.g. '/file.ext' (required)
        :param str storage_name: Storage name
        :return: FileVersions
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_versions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `get_file_versions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/version/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileVersions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_files_list(self, path, **kwargs):  # noqa: E501
        """Get all files and folders within a folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_files_list(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: Folder path e.g. '/folder' (required)
        :param str storage_name: Storage name
        :return: FilesList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_files_list_with_http_info(path, **kwargs)  # noqa: E501
        else:
            (data) = self.get_files_list_with_http_info(path, **kwargs)  # noqa: E501
            return data

    def get_files_list_with_http_info(self, path, **kwargs):  # noqa: E501
        """Get all files and folders within a folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_files_list_with_http_info(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: Folder path e.g. '/folder' (required)
        :param str storage_name: Storage name
        :return: FilesList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_files_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `get_files_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/folder/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilesList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_bmp(self, name, bits_per_pixel, horizontal_resolution, vertical_resolution, **kwargs):  # noqa: E501
        """Update parameters of existing BMP image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_bmp(name, bits_per_pixel, horizontal_resolution, vertical_resolution, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param int bits_per_pixel: Color depth. (required)
        :param int horizontal_resolution: New horizontal resolution. (required)
        :param int vertical_resolution: New vertical resolution. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_bmp_with_http_info(name, bits_per_pixel, horizontal_resolution, vertical_resolution, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_bmp_with_http_info(name, bits_per_pixel, horizontal_resolution, vertical_resolution, **kwargs)  # noqa: E501
            return data

    def get_image_bmp_with_http_info(self, name, bits_per_pixel, horizontal_resolution, vertical_resolution, **kwargs):  # noqa: E501
        """Update parameters of existing BMP image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_bmp_with_http_info(name, bits_per_pixel, horizontal_resolution, vertical_resolution, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param int bits_per_pixel: Color depth. (required)
        :param int horizontal_resolution: New horizontal resolution. (required)
        :param int vertical_resolution: New vertical resolution. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'bits_per_pixel', 'horizontal_resolution', 'vertical_resolution', 'from_scratch', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_bmp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_bmp`")  # noqa: E501
        # verify the required parameter 'bits_per_pixel' is set
        if ('bits_per_pixel' not in params or
                params['bits_per_pixel'] is None):
            raise ValueError("Missing the required parameter `bits_per_pixel` when calling `get_image_bmp`")  # noqa: E501
        # verify the required parameter 'horizontal_resolution' is set
        if ('horizontal_resolution' not in params or
                params['horizontal_resolution'] is None):
            raise ValueError("Missing the required parameter `horizontal_resolution` when calling `get_image_bmp`")  # noqa: E501
        # verify the required parameter 'vertical_resolution' is set
        if ('vertical_resolution' not in params or
                params['vertical_resolution'] is None):
            raise ValueError("Missing the required parameter `vertical_resolution` when calling `get_image_bmp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'bits_per_pixel' in params:
            query_params.append(('bitsPerPixel', params['bits_per_pixel']))  # noqa: E501
        if 'horizontal_resolution' in params:
            query_params.append(('horizontalResolution', params['horizontal_resolution']))  # noqa: E501
        if 'vertical_resolution' in params:
            query_params.append(('verticalResolution', params['vertical_resolution']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/bmp', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_crop(self, name, format, x, y, width, height, **kwargs):  # noqa: E501
        """Crop an existing image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_crop(name, format, x, y, width, height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of an image. (required)
        :param str format: Resulting image format. (required)
        :param int x: X position of start point for cropping rectangle. (required)
        :param int y: Y position of start point for cropping rectangle. (required)
        :param int width: Width of cropping rectangle (required)
        :param int height: Height of cropping rectangle. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_crop_with_http_info(name, format, x, y, width, height, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_crop_with_http_info(name, format, x, y, width, height, **kwargs)  # noqa: E501
            return data

    def get_image_crop_with_http_info(self, name, format, x, y, width, height, **kwargs):  # noqa: E501
        """Crop an existing image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_crop_with_http_info(name, format, x, y, width, height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of an image. (required)
        :param str format: Resulting image format. (required)
        :param int x: X position of start point for cropping rectangle. (required)
        :param int y: Y position of start point for cropping rectangle. (required)
        :param int width: Width of cropping rectangle (required)
        :param int height: Height of cropping rectangle. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'format', 'x', 'y', 'width', 'height', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_crop" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_crop`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `get_image_crop`")  # noqa: E501
        # verify the required parameter 'x' is set
        if ('x' not in params or
                params['x'] is None):
            raise ValueError("Missing the required parameter `x` when calling `get_image_crop`")  # noqa: E501
        # verify the required parameter 'y' is set
        if ('y' not in params or
                params['y'] is None):
            raise ValueError("Missing the required parameter `y` when calling `get_image_crop`")  # noqa: E501
        # verify the required parameter 'width' is set
        if ('width' not in params or
                params['width'] is None):
            raise ValueError("Missing the required parameter `width` when calling `get_image_crop`")  # noqa: E501
        # verify the required parameter 'height' is set
        if ('height' not in params or
                params['height'] is None):
            raise ValueError("Missing the required parameter `height` when calling `get_image_crop`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'x' in params:
            query_params.append(('x', params['x']))  # noqa: E501
        if 'y' in params:
            query_params.append(('y', params['y']))  # noqa: E501
        if 'width' in params:
            query_params.append(('width', params['width']))  # noqa: E501
        if 'height' in params:
            query_params.append(('height', params['height']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/crop', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_emf(self, name, bk_color, page_width, page_height, border_x, border_y, **kwargs):  # noqa: E501
        """Process existing EMF imaging using given parameters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_emf(name, bk_color, page_width, page_height, border_x, border_y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str bk_color: Color of the background. (required)
        :param int page_width: Width of the page. (required)
        :param int page_height: Height of the page. (required)
        :param int border_x: Border width. (required)
        :param int border_y: Border height. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :param str format: Export format (PNG is the default one).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_emf_with_http_info(name, bk_color, page_width, page_height, border_x, border_y, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_emf_with_http_info(name, bk_color, page_width, page_height, border_x, border_y, **kwargs)  # noqa: E501
            return data

    def get_image_emf_with_http_info(self, name, bk_color, page_width, page_height, border_x, border_y, **kwargs):  # noqa: E501
        """Process existing EMF imaging using given parameters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_emf_with_http_info(name, bk_color, page_width, page_height, border_x, border_y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str bk_color: Color of the background. (required)
        :param int page_width: Width of the page. (required)
        :param int page_height: Height of the page. (required)
        :param int border_x: Border width. (required)
        :param int border_y: Border height. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :param str format: Export format (PNG is the default one).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'bk_color', 'page_width', 'page_height', 'border_x', 'border_y', 'from_scratch', 'out_path', 'folder', 'storage', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_emf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_emf`")  # noqa: E501
        # verify the required parameter 'bk_color' is set
        if ('bk_color' not in params or
                params['bk_color'] is None):
            raise ValueError("Missing the required parameter `bk_color` when calling `get_image_emf`")  # noqa: E501
        # verify the required parameter 'page_width' is set
        if ('page_width' not in params or
                params['page_width'] is None):
            raise ValueError("Missing the required parameter `page_width` when calling `get_image_emf`")  # noqa: E501
        # verify the required parameter 'page_height' is set
        if ('page_height' not in params or
                params['page_height'] is None):
            raise ValueError("Missing the required parameter `page_height` when calling `get_image_emf`")  # noqa: E501
        # verify the required parameter 'border_x' is set
        if ('border_x' not in params or
                params['border_x'] is None):
            raise ValueError("Missing the required parameter `border_x` when calling `get_image_emf`")  # noqa: E501
        # verify the required parameter 'border_y' is set
        if ('border_y' not in params or
                params['border_y'] is None):
            raise ValueError("Missing the required parameter `border_y` when calling `get_image_emf`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'bk_color' in params:
            query_params.append(('bkColor', params['bk_color']))  # noqa: E501
        if 'page_width' in params:
            query_params.append(('pageWidth', params['page_width']))  # noqa: E501
        if 'page_height' in params:
            query_params.append(('pageHeight', params['page_height']))  # noqa: E501
        if 'border_x' in params:
            query_params.append(('borderX', params['border_x']))  # noqa: E501
        if 'border_y' in params:
            query_params.append(('borderY', params['border_y']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/emf', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_frame(self, name, frame_id, **kwargs):  # noqa: E501
        """Get separate frame from existing TIFF image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_frame(name, frame_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param int frame_id: Number of a frame. (required)
        :param int new_width: New width.
        :param int new_height: New height.
        :param int x: X position of start point for cropping rectangle.
        :param int y: Y position of start point for cropping rectangle.
        :param int rect_width: Width of cropping rectangle.
        :param int rect_height: Height of cropping rectangle.
        :param str rotate_flip_method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). Default is RotateNoneFlipNone.
        :param bool save_other_frames: If result will include all other frames or just a specified frame.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_frame_with_http_info(name, frame_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_frame_with_http_info(name, frame_id, **kwargs)  # noqa: E501
            return data

    def get_image_frame_with_http_info(self, name, frame_id, **kwargs):  # noqa: E501
        """Get separate frame from existing TIFF image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_frame_with_http_info(name, frame_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param int frame_id: Number of a frame. (required)
        :param int new_width: New width.
        :param int new_height: New height.
        :param int x: X position of start point for cropping rectangle.
        :param int y: Y position of start point for cropping rectangle.
        :param int rect_width: Width of cropping rectangle.
        :param int rect_height: Height of cropping rectangle.
        :param str rotate_flip_method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). Default is RotateNoneFlipNone.
        :param bool save_other_frames: If result will include all other frames or just a specified frame.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'frame_id', 'new_width', 'new_height', 'x', 'y', 'rect_width', 'rect_height', 'rotate_flip_method', 'save_other_frames', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_frame" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_frame`")  # noqa: E501
        # verify the required parameter 'frame_id' is set
        if ('frame_id' not in params or
                params['frame_id'] is None):
            raise ValueError("Missing the required parameter `frame_id` when calling `get_image_frame`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'frame_id' in params:
            path_params['frameId'] = params['frame_id']  # noqa: E501

        query_params = []
        if 'new_width' in params:
            query_params.append(('newWidth', params['new_width']))  # noqa: E501
        if 'new_height' in params:
            query_params.append(('newHeight', params['new_height']))  # noqa: E501
        if 'x' in params:
            query_params.append(('x', params['x']))  # noqa: E501
        if 'y' in params:
            query_params.append(('y', params['y']))  # noqa: E501
        if 'rect_width' in params:
            query_params.append(('rectWidth', params['rect_width']))  # noqa: E501
        if 'rect_height' in params:
            query_params.append(('rectHeight', params['rect_height']))  # noqa: E501
        if 'rotate_flip_method' in params:
            query_params.append(('rotateFlipMethod', params['rotate_flip_method']))  # noqa: E501
        if 'save_other_frames' in params:
            query_params.append(('saveOtherFrames', params['save_other_frames']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/frames/{frameId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_frame_properties(self, name, frame_id, **kwargs):  # noqa: E501
        """Get separate frame properties of existing TIFF image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_frame_properties(name, frame_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename with image. (required)
        :param int frame_id: Number of a frame. (required)
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: ImagingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_frame_properties_with_http_info(name, frame_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_frame_properties_with_http_info(name, frame_id, **kwargs)  # noqa: E501
            return data

    def get_image_frame_properties_with_http_info(self, name, frame_id, **kwargs):  # noqa: E501
        """Get separate frame properties of existing TIFF image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_frame_properties_with_http_info(name, frame_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename with image. (required)
        :param int frame_id: Number of a frame. (required)
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: ImagingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'frame_id', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_frame_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_frame_properties`")  # noqa: E501
        # verify the required parameter 'frame_id' is set
        if ('frame_id' not in params or
                params['frame_id'] is None):
            raise ValueError("Missing the required parameter `frame_id` when calling `get_image_frame_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'frame_id' in params:
            path_params['frameId'] = params['frame_id']  # noqa: E501

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/frames/{frameId}/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImagingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_gif(self, name, **kwargs):  # noqa: E501
        """Update parameters of existing GIF image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_gif(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param int background_color_index: Index of the background color.
        :param int color_resolution: Color resolution.
        :param bool has_trailer: Specifies if image has trailer.
        :param bool interlaced: Specifies if image is interlaced.
        :param bool is_palette_sorted: Specifies if palette is sorted.
        :param int pixel_aspect_ratio: Pixel aspect ratio.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_gif_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_gif_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_image_gif_with_http_info(self, name, **kwargs):  # noqa: E501
        """Update parameters of existing GIF image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_gif_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param int background_color_index: Index of the background color.
        :param int color_resolution: Color resolution.
        :param bool has_trailer: Specifies if image has trailer.
        :param bool interlaced: Specifies if image is interlaced.
        :param bool is_palette_sorted: Specifies if palette is sorted.
        :param int pixel_aspect_ratio: Pixel aspect ratio.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'background_color_index', 'color_resolution', 'has_trailer', 'interlaced', 'is_palette_sorted', 'pixel_aspect_ratio', 'from_scratch', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_gif" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_gif`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'background_color_index' in params:
            query_params.append(('backgroundColorIndex', params['background_color_index']))  # noqa: E501
        if 'color_resolution' in params:
            query_params.append(('colorResolution', params['color_resolution']))  # noqa: E501
        if 'has_trailer' in params:
            query_params.append(('hasTrailer', params['has_trailer']))  # noqa: E501
        if 'interlaced' in params:
            query_params.append(('interlaced', params['interlaced']))  # noqa: E501
        if 'is_palette_sorted' in params:
            query_params.append(('isPaletteSorted', params['is_palette_sorted']))  # noqa: E501
        if 'pixel_aspect_ratio' in params:
            query_params.append(('pixelAspectRatio', params['pixel_aspect_ratio']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/gif', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_jpeg2000(self, name, comment, **kwargs):  # noqa: E501
        """Update parameters of existing JPEG2000 image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_jpeg2000(name, comment, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str comment: The comment. (required)
        :param str codec: The codec.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_jpeg2000_with_http_info(name, comment, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_jpeg2000_with_http_info(name, comment, **kwargs)  # noqa: E501
            return data

    def get_image_jpeg2000_with_http_info(self, name, comment, **kwargs):  # noqa: E501
        """Update parameters of existing JPEG2000 image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_jpeg2000_with_http_info(name, comment, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str comment: The comment. (required)
        :param str codec: The codec.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'comment', 'codec', 'from_scratch', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_jpeg2000" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_jpeg2000`")  # noqa: E501
        # verify the required parameter 'comment' is set
        if ('comment' not in params or
                params['comment'] is None):
            raise ValueError("Missing the required parameter `comment` when calling `get_image_jpeg2000`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'comment' in params:
            query_params.append(('comment', params['comment']))  # noqa: E501
        if 'codec' in params:
            query_params.append(('codec', params['codec']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/jpg2000', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_jpg(self, name, **kwargs):  # noqa: E501
        """Update parameters of existing JPEG image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_jpg(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param int quality: Quality of an image from 0 to 100. Default is 75.
        :param str compression_type: Compression type.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_jpg_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_jpg_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_image_jpg_with_http_info(self, name, **kwargs):  # noqa: E501
        """Update parameters of existing JPEG image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_jpg_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param int quality: Quality of an image from 0 to 100. Default is 75.
        :param str compression_type: Compression type.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'quality', 'compression_type', 'from_scratch', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_jpg" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_jpg`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'quality' in params:
            query_params.append(('quality', params['quality']))  # noqa: E501
        if 'compression_type' in params:
            query_params.append(('compressionType', params['compression_type']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/jpg', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_properties(self, name, **kwargs):  # noqa: E501
        """Get properties of an image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_properties(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of an image. (required)
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: ImagingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_properties_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_properties_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_image_properties_with_http_info(self, name, **kwargs):  # noqa: E501
        """Get properties of an image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_properties_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of an image. (required)
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: ImagingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImagingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_psd(self, name, **kwargs):  # noqa: E501
        """Update parameters of existing PSD image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_psd(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param int channels_count: Count of color channels.
        :param str compression_method: Compression method.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_psd_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_psd_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_image_psd_with_http_info(self, name, **kwargs):  # noqa: E501
        """Update parameters of existing PSD image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_psd_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param int channels_count: Count of color channels.
        :param str compression_method: Compression method.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'channels_count', 'compression_method', 'from_scratch', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_psd" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_psd`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'channels_count' in params:
            query_params.append(('channelsCount', params['channels_count']))  # noqa: E501
        if 'compression_method' in params:
            query_params.append(('compressionMethod', params['compression_method']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/psd', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_resize(self, name, format, new_width, new_height, **kwargs):  # noqa: E501
        """Resize an existing image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_resize(name, format, new_width, new_height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of an image. (required)
        :param str format: Resulting image format. (required)
        :param int new_width: New width. (required)
        :param int new_height: New height. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_resize_with_http_info(name, format, new_width, new_height, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_resize_with_http_info(name, format, new_width, new_height, **kwargs)  # noqa: E501
            return data

    def get_image_resize_with_http_info(self, name, format, new_width, new_height, **kwargs):  # noqa: E501
        """Resize an existing image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_resize_with_http_info(name, format, new_width, new_height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of an image. (required)
        :param str format: Resulting image format. (required)
        :param int new_width: New width. (required)
        :param int new_height: New height. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'format', 'new_width', 'new_height', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_resize" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_resize`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `get_image_resize`")  # noqa: E501
        # verify the required parameter 'new_width' is set
        if ('new_width' not in params or
                params['new_width'] is None):
            raise ValueError("Missing the required parameter `new_width` when calling `get_image_resize`")  # noqa: E501
        # verify the required parameter 'new_height' is set
        if ('new_height' not in params or
                params['new_height'] is None):
            raise ValueError("Missing the required parameter `new_height` when calling `get_image_resize`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'new_width' in params:
            query_params.append(('newWidth', params['new_width']))  # noqa: E501
        if 'new_height' in params:
            query_params.append(('newHeight', params['new_height']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/resize', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_rotate_flip(self, name, format, method, **kwargs):  # noqa: E501
        """Rotate and/or flip an existing image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_rotate_flip(name, format, method, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of an image. (required)
        :param str format: Resulting image format. (required)
        :param str method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_rotate_flip_with_http_info(name, format, method, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_rotate_flip_with_http_info(name, format, method, **kwargs)  # noqa: E501
            return data

    def get_image_rotate_flip_with_http_info(self, name, format, method, **kwargs):  # noqa: E501
        """Rotate and/or flip an existing image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_rotate_flip_with_http_info(name, format, method, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of an image. (required)
        :param str format: Resulting image format. (required)
        :param str method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'format', 'method', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_rotate_flip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_rotate_flip`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `get_image_rotate_flip`")  # noqa: E501
        # verify the required parameter 'method' is set
        if ('method' not in params or
                params['method'] is None):
            raise ValueError("Missing the required parameter `method` when calling `get_image_rotate_flip`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'method' in params:
            query_params.append(('method', params['method']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/rotateflip', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_save_as(self, name, format, **kwargs):  # noqa: E501
        """Export existing image to another format.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_save_as(name, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str format: Resulting image format. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_save_as_with_http_info(name, format, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_save_as_with_http_info(name, format, **kwargs)  # noqa: E501
            return data

    def get_image_save_as_with_http_info(self, name, format, **kwargs):  # noqa: E501
        """Export existing image to another format.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_save_as_with_http_info(name, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str format: Resulting image format. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'format', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_save_as" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_save_as`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `get_image_save_as`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/saveAs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_tiff(self, name, compression, resolution_unit, bit_depth, **kwargs):  # noqa: E501
        """Update parameters of existing TIFF image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_tiff(name, compression, resolution_unit, bit_depth, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str compression: Compression. (required)
        :param str resolution_unit: New resolution unit. (required)
        :param int bit_depth: Bit depth. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param float horizontal_resolution: New horizontal resolution.
        :param float vertical_resolution: New verstical resolution.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_tiff_with_http_info(name, compression, resolution_unit, bit_depth, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_tiff_with_http_info(name, compression, resolution_unit, bit_depth, **kwargs)  # noqa: E501
            return data

    def get_image_tiff_with_http_info(self, name, compression, resolution_unit, bit_depth, **kwargs):  # noqa: E501
        """Update parameters of existing TIFF image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_tiff_with_http_info(name, compression, resolution_unit, bit_depth, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str compression: Compression. (required)
        :param str resolution_unit: New resolution unit. (required)
        :param int bit_depth: Bit depth. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param float horizontal_resolution: New horizontal resolution.
        :param float vertical_resolution: New verstical resolution.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'compression', 'resolution_unit', 'bit_depth', 'from_scratch', 'horizontal_resolution', 'vertical_resolution', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_tiff" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_tiff`")  # noqa: E501
        # verify the required parameter 'compression' is set
        if ('compression' not in params or
                params['compression'] is None):
            raise ValueError("Missing the required parameter `compression` when calling `get_image_tiff`")  # noqa: E501
        # verify the required parameter 'resolution_unit' is set
        if ('resolution_unit' not in params or
                params['resolution_unit'] is None):
            raise ValueError("Missing the required parameter `resolution_unit` when calling `get_image_tiff`")  # noqa: E501
        # verify the required parameter 'bit_depth' is set
        if ('bit_depth' not in params or
                params['bit_depth'] is None):
            raise ValueError("Missing the required parameter `bit_depth` when calling `get_image_tiff`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'compression' in params:
            query_params.append(('compression', params['compression']))  # noqa: E501
        if 'resolution_unit' in params:
            query_params.append(('resolutionUnit', params['resolution_unit']))  # noqa: E501
        if 'bit_depth' in params:
            query_params.append(('bitDepth', params['bit_depth']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'horizontal_resolution' in params:
            query_params.append(('horizontalResolution', params['horizontal_resolution']))  # noqa: E501
        if 'vertical_resolution' in params:
            query_params.append(('verticalResolution', params['vertical_resolution']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/tiff', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_update(self, name, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, **kwargs):  # noqa: E501
        """Perform scaling, cropping and flipping of an existing image in a single request.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_update(name, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of an image. (required)
        :param str format: Resulting image format. (required)
        :param int new_width: New width of the scaled image. (required)
        :param int new_height: New height of the scaled image. (required)
        :param int x: X position of start point for cropping rectangle. (required)
        :param int y: Y position of start point for cropping rectangle. (required)
        :param int rect_width: Width of cropping rectangle. (required)
        :param int rect_height: Height of cropping rectangle. (required)
        :param str rotate_flip_method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). Default is RotateNoneFlipNone. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_update_with_http_info(name, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_update_with_http_info(name, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, **kwargs)  # noqa: E501
            return data

    def get_image_update_with_http_info(self, name, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, **kwargs):  # noqa: E501
        """Perform scaling, cropping and flipping of an existing image in a single request.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_update_with_http_info(name, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of an image. (required)
        :param str format: Resulting image format. (required)
        :param int new_width: New width of the scaled image. (required)
        :param int new_height: New height of the scaled image. (required)
        :param int x: X position of start point for cropping rectangle. (required)
        :param int y: Y position of start point for cropping rectangle. (required)
        :param int rect_width: Width of cropping rectangle. (required)
        :param int rect_height: Height of cropping rectangle. (required)
        :param str rotate_flip_method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). Default is RotateNoneFlipNone. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'format', 'new_width', 'new_height', 'x', 'y', 'rect_width', 'rect_height', 'rotate_flip_method', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_update`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `get_image_update`")  # noqa: E501
        # verify the required parameter 'new_width' is set
        if ('new_width' not in params or
                params['new_width'] is None):
            raise ValueError("Missing the required parameter `new_width` when calling `get_image_update`")  # noqa: E501
        # verify the required parameter 'new_height' is set
        if ('new_height' not in params or
                params['new_height'] is None):
            raise ValueError("Missing the required parameter `new_height` when calling `get_image_update`")  # noqa: E501
        # verify the required parameter 'x' is set
        if ('x' not in params or
                params['x'] is None):
            raise ValueError("Missing the required parameter `x` when calling `get_image_update`")  # noqa: E501
        # verify the required parameter 'y' is set
        if ('y' not in params or
                params['y'] is None):
            raise ValueError("Missing the required parameter `y` when calling `get_image_update`")  # noqa: E501
        # verify the required parameter 'rect_width' is set
        if ('rect_width' not in params or
                params['rect_width'] is None):
            raise ValueError("Missing the required parameter `rect_width` when calling `get_image_update`")  # noqa: E501
        # verify the required parameter 'rect_height' is set
        if ('rect_height' not in params or
                params['rect_height'] is None):
            raise ValueError("Missing the required parameter `rect_height` when calling `get_image_update`")  # noqa: E501
        # verify the required parameter 'rotate_flip_method' is set
        if ('rotate_flip_method' not in params or
                params['rotate_flip_method'] is None):
            raise ValueError("Missing the required parameter `rotate_flip_method` when calling `get_image_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'new_width' in params:
            query_params.append(('newWidth', params['new_width']))  # noqa: E501
        if 'new_height' in params:
            query_params.append(('newHeight', params['new_height']))  # noqa: E501
        if 'x' in params:
            query_params.append(('x', params['x']))  # noqa: E501
        if 'y' in params:
            query_params.append(('y', params['y']))  # noqa: E501
        if 'rect_width' in params:
            query_params.append(('rectWidth', params['rect_width']))  # noqa: E501
        if 'rect_height' in params:
            query_params.append(('rectHeight', params['rect_height']))  # noqa: E501
        if 'rotate_flip_method' in params:
            query_params.append(('rotateFlipMethod', params['rotate_flip_method']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/updateImage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_web_p(self, name, loss_less, quality, anim_loop_count, anim_background_color, **kwargs):  # noqa: E501
        """Update parameters of existing WEBP image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_web_p(name, loss_less, quality, anim_loop_count, anim_background_color, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param bool loss_less: If WEBP is lossless. (required)
        :param int quality: Quality. (required)
        :param int anim_loop_count: The animation loop count. (required)
        :param str anim_background_color: Color of the animation background. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_web_p_with_http_info(name, loss_less, quality, anim_loop_count, anim_background_color, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_web_p_with_http_info(name, loss_less, quality, anim_loop_count, anim_background_color, **kwargs)  # noqa: E501
            return data

    def get_image_web_p_with_http_info(self, name, loss_less, quality, anim_loop_count, anim_background_color, **kwargs):  # noqa: E501
        """Update parameters of existing WEBP image.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_web_p_with_http_info(name, loss_less, quality, anim_loop_count, anim_background_color, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param bool loss_less: If WEBP is lossless. (required)
        :param int quality: Quality. (required)
        :param int anim_loop_count: The animation loop count. (required)
        :param str anim_background_color: Color of the animation background. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'loss_less', 'quality', 'anim_loop_count', 'anim_background_color', 'from_scratch', 'out_path', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_web_p" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_web_p`")  # noqa: E501
        # verify the required parameter 'loss_less' is set
        if ('loss_less' not in params or
                params['loss_less'] is None):
            raise ValueError("Missing the required parameter `loss_less` when calling `get_image_web_p`")  # noqa: E501
        # verify the required parameter 'quality' is set
        if ('quality' not in params or
                params['quality'] is None):
            raise ValueError("Missing the required parameter `quality` when calling `get_image_web_p`")  # noqa: E501
        # verify the required parameter 'anim_loop_count' is set
        if ('anim_loop_count' not in params or
                params['anim_loop_count'] is None):
            raise ValueError("Missing the required parameter `anim_loop_count` when calling `get_image_web_p`")  # noqa: E501
        # verify the required parameter 'anim_background_color' is set
        if ('anim_background_color' not in params or
                params['anim_background_color'] is None):
            raise ValueError("Missing the required parameter `anim_background_color` when calling `get_image_web_p`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'loss_less' in params:
            query_params.append(('lossLess', params['loss_less']))  # noqa: E501
        if 'quality' in params:
            query_params.append(('quality', params['quality']))  # noqa: E501
        if 'anim_loop_count' in params:
            query_params.append(('animLoopCount', params['anim_loop_count']))  # noqa: E501
        if 'anim_background_color' in params:
            query_params.append(('animBackgroundColor', params['anim_background_color']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/webp', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_image_wmf(self, name, bk_color, page_width, page_height, border_x, border_y, **kwargs):  # noqa: E501
        """Process existing WMF image using given parameters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_wmf(name, bk_color, page_width, page_height, border_x, border_y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str bk_color: Color of the background. (required)
        :param int page_width: Width of the page. (required)
        :param int page_height: Height of the page. (required)
        :param int border_x: Border width. (required)
        :param int border_y: Border height. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :param str format: Export format (PNG is the default one).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_image_wmf_with_http_info(name, bk_color, page_width, page_height, border_x, border_y, **kwargs)  # noqa: E501
        else:
            (data) = self.get_image_wmf_with_http_info(name, bk_color, page_width, page_height, border_x, border_y, **kwargs)  # noqa: E501
            return data

    def get_image_wmf_with_http_info(self, name, bk_color, page_width, page_height, border_x, border_y, **kwargs):  # noqa: E501
        """Process existing WMF image using given parameters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_image_wmf_with_http_info(name, bk_color, page_width, page_height, border_x, border_y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str bk_color: Color of the background. (required)
        :param int page_width: Width of the page. (required)
        :param int page_height: Height of the page. (required)
        :param int border_x: Border width. (required)
        :param int border_y: Border height. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str folder: Folder with image to process.
        :param str storage: Your Aspose Cloud Storage name.
        :param str format: Export format (PNG is the default one).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'bk_color', 'page_width', 'page_height', 'border_x', 'border_y', 'from_scratch', 'out_path', 'folder', 'storage', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image_wmf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_image_wmf`")  # noqa: E501
        # verify the required parameter 'bk_color' is set
        if ('bk_color' not in params or
                params['bk_color'] is None):
            raise ValueError("Missing the required parameter `bk_color` when calling `get_image_wmf`")  # noqa: E501
        # verify the required parameter 'page_width' is set
        if ('page_width' not in params or
                params['page_width'] is None):
            raise ValueError("Missing the required parameter `page_width` when calling `get_image_wmf`")  # noqa: E501
        # verify the required parameter 'page_height' is set
        if ('page_height' not in params or
                params['page_height'] is None):
            raise ValueError("Missing the required parameter `page_height` when calling `get_image_wmf`")  # noqa: E501
        # verify the required parameter 'border_x' is set
        if ('border_x' not in params or
                params['border_x'] is None):
            raise ValueError("Missing the required parameter `border_x` when calling `get_image_wmf`")  # noqa: E501
        # verify the required parameter 'border_y' is set
        if ('border_y' not in params or
                params['border_y'] is None):
            raise ValueError("Missing the required parameter `border_y` when calling `get_image_wmf`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'bk_color' in params:
            query_params.append(('bkColor', params['bk_color']))  # noqa: E501
        if 'page_width' in params:
            query_params.append(('pageWidth', params['page_width']))  # noqa: E501
        if 'page_height' in params:
            query_params.append(('pageHeight', params['page_height']))  # noqa: E501
        if 'border_x' in params:
            query_params.append(('borderX', params['border_x']))  # noqa: E501
        if 'border_y' in params:
            query_params.append(('borderY', params['border_y']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/{name}/wmf', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_search_context_extract_image_features(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Extract features from image without adding to search context. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_extract_image_features(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str image_id: The image identifier. (required)
        :param file image_data: Input image
        :param str folder: The folder.
        :param str storage: The storage.
        :return: ImageFeatures
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_search_context_extract_image_features_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_search_context_extract_image_features_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
            return data

    def get_search_context_extract_image_features_with_http_info(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Extract features from image without adding to search context. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_extract_image_features_with_http_info(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str image_id: The image identifier. (required)
        :param file image_data: Input image
        :param str folder: The folder.
        :param str storage: The storage.
        :return: ImageFeatures
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'image_id', 'image_data', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_search_context_extract_image_features" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `get_search_context_extract_image_features`")  # noqa: E501
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params or
                params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `get_search_context_extract_image_features`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'image_id' in params:
            query_params.append(('imageId', params['image_id']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/image2features', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImageFeatures',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_search_context_find_duplicates(self, search_context_id, similarity_threshold, **kwargs):  # noqa: E501
        """Find images duplicates.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_find_duplicates(search_context_id, similarity_threshold, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param float similarity_threshold: The similarity threshold. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: ImageDuplicatesSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_search_context_find_duplicates_with_http_info(search_context_id, similarity_threshold, **kwargs)  # noqa: E501
        else:
            (data) = self.get_search_context_find_duplicates_with_http_info(search_context_id, similarity_threshold, **kwargs)  # noqa: E501
            return data

    def get_search_context_find_duplicates_with_http_info(self, search_context_id, similarity_threshold, **kwargs):  # noqa: E501
        """Find images duplicates.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_find_duplicates_with_http_info(search_context_id, similarity_threshold, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param float similarity_threshold: The similarity threshold. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: ImageDuplicatesSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'similarity_threshold', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_search_context_find_duplicates" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `get_search_context_find_duplicates`")  # noqa: E501
        # verify the required parameter 'similarity_threshold' is set
        if ('similarity_threshold' not in params or
                params['similarity_threshold'] is None):
            raise ValueError("Missing the required parameter `similarity_threshold` when calling `get_search_context_find_duplicates`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'similarity_threshold' in params:
            query_params.append(('similarityThreshold', params['similarity_threshold']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/findDuplicates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImageDuplicatesSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_search_context_find_similar(self, search_context_id, similarity_threshold, max_count, **kwargs):  # noqa: E501
        """Find similar images. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_find_similar(search_context_id, similarity_threshold, max_count, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param float similarity_threshold: The similarity threshold. (required)
        :param int max_count: The maximum count. (required)
        :param file image_data: Input image
        :param str image_id: The search image identifier.
        :param str folder: The folder.
        :param str storage: The storage.
        :return: SearchResultsSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_search_context_find_similar_with_http_info(search_context_id, similarity_threshold, max_count, **kwargs)  # noqa: E501
        else:
            (data) = self.get_search_context_find_similar_with_http_info(search_context_id, similarity_threshold, max_count, **kwargs)  # noqa: E501
            return data

    def get_search_context_find_similar_with_http_info(self, search_context_id, similarity_threshold, max_count, **kwargs):  # noqa: E501
        """Find similar images. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_find_similar_with_http_info(search_context_id, similarity_threshold, max_count, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param float similarity_threshold: The similarity threshold. (required)
        :param int max_count: The maximum count. (required)
        :param file image_data: Input image
        :param str image_id: The search image identifier.
        :param str folder: The folder.
        :param str storage: The storage.
        :return: SearchResultsSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'similarity_threshold', 'max_count', 'image_data', 'image_id', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_search_context_find_similar" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `get_search_context_find_similar`")  # noqa: E501
        # verify the required parameter 'similarity_threshold' is set
        if ('similarity_threshold' not in params or
                params['similarity_threshold'] is None):
            raise ValueError("Missing the required parameter `similarity_threshold` when calling `get_search_context_find_similar`")  # noqa: E501
        # verify the required parameter 'max_count' is set
        if ('max_count' not in params or
                params['max_count'] is None):
            raise ValueError("Missing the required parameter `max_count` when calling `get_search_context_find_similar`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'similarity_threshold' in params:
            query_params.append(('similarityThreshold', params['similarity_threshold']))  # noqa: E501
        if 'max_count' in params:
            query_params.append(('maxCount', params['max_count']))  # noqa: E501
        if 'image_id' in params:
            query_params.append(('imageId', params['image_id']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/findSimilar', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchResultsSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_search_context_image(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Get image from search context  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_image(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: Search context identifier. (required)
        :param str image_id: Image identifier. (required)
        :param str folder: Folder.
        :param str storage: Storage
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_search_context_image_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_search_context_image_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
            return data

    def get_search_context_image_with_http_info(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Get image from search context  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_image_with_http_info(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: Search context identifier. (required)
        :param str image_id: Image identifier. (required)
        :param str folder: Folder.
        :param str storage: Storage
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'image_id', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_search_context_image" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `get_search_context_image`")  # noqa: E501
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params or
                params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `get_search_context_image`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'image_id' in params:
            query_params.append(('imageId', params['image_id']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/image', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_search_context_image_features(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Gets image features from search context.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_image_features(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str image_id: The image identifier. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: ImageFeatures
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_search_context_image_features_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_search_context_image_features_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
            return data

    def get_search_context_image_features_with_http_info(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Gets image features from search context.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_image_features_with_http_info(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str image_id: The image identifier. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: ImageFeatures
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'image_id', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_search_context_image_features" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `get_search_context_image_features`")  # noqa: E501
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params or
                params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `get_search_context_image_features`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'image_id' in params:
            query_params.append(('imageId', params['image_id']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/features', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImageFeatures',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_search_context_status(self, search_context_id, **kwargs):  # noqa: E501
        """Gets the search context status.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_status(search_context_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: SearchContextStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_search_context_status_with_http_info(search_context_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_search_context_status_with_http_info(search_context_id, **kwargs)  # noqa: E501
            return data

    def get_search_context_status_with_http_info(self, search_context_id, **kwargs):  # noqa: E501
        """Gets the search context status.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_search_context_status_with_http_info(search_context_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: SearchContextStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_search_context_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `get_search_context_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchContextStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tiff_to_fax(self, name, **kwargs):  # noqa: E501
        """Update parameters of existing TIFF image accordingly to fax parameters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tiff_to_fax(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str storage: Your Aspose Cloud Storage name.
        :param str folder: Folder with image to process.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_tiff_to_fax_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tiff_to_fax_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_tiff_to_fax_with_http_info(self, name, **kwargs):  # noqa: E501
        """Update parameters of existing TIFF image accordingly to fax parameters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tiff_to_fax_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Filename of image. (required)
        :param str storage: Your Aspose Cloud Storage name.
        :param str folder: Folder with image to process.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'storage', 'folder', 'out_path']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tiff_to_fax" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_tiff_to_fax`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/tiff/{name}/toFax', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def move_file(self, src_path, dest_path, **kwargs):  # noqa: E501
        """Move file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.move_file(src_path, dest_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str src_path: Source file path e.g. '/src.ext' (required)
        :param str dest_path: Destination file path e.g. '/dest.ext' (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :param str version_id: File version ID to move
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.move_file_with_http_info(src_path, dest_path, **kwargs)  # noqa: E501
        else:
            (data) = self.move_file_with_http_info(src_path, dest_path, **kwargs)  # noqa: E501
            return data

    def move_file_with_http_info(self, src_path, dest_path, **kwargs):  # noqa: E501
        """Move file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.move_file_with_http_info(src_path, dest_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str src_path: Source file path e.g. '/src.ext' (required)
        :param str dest_path: Destination file path e.g. '/dest.ext' (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :param str version_id: File version ID to move
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'dest_path', 'src_storage_name', 'dest_storage_name', 'version_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method move_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params or
                params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `move_file`")  # noqa: E501
        # verify the required parameter 'dest_path' is set
        if ('dest_path' not in params or
                params['dest_path'] is None):
            raise ValueError("Missing the required parameter `dest_path` when calling `move_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'src_path' in params:
            path_params['srcPath'] = params['src_path']  # noqa: E501

        query_params = []
        if 'dest_path' in params:
            query_params.append(('destPath', params['dest_path']))  # noqa: E501
        if 'src_storage_name' in params:
            query_params.append(('srcStorageName', params['src_storage_name']))  # noqa: E501
        if 'dest_storage_name' in params:
            query_params.append(('destStorageName', params['dest_storage_name']))  # noqa: E501
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/file/move/{srcPath}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def move_folder(self, src_path, dest_path, **kwargs):  # noqa: E501
        """Move folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.move_folder(src_path, dest_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str src_path: Folder path to move e.g. '/folder' (required)
        :param str dest_path: Destination folder path to move to e.g '/dst' (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.move_folder_with_http_info(src_path, dest_path, **kwargs)  # noqa: E501
        else:
            (data) = self.move_folder_with_http_info(src_path, dest_path, **kwargs)  # noqa: E501
            return data

    def move_folder_with_http_info(self, src_path, dest_path, **kwargs):  # noqa: E501
        """Move folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.move_folder_with_http_info(src_path, dest_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str src_path: Folder path to move e.g. '/folder' (required)
        :param str dest_path: Destination folder path to move to e.g '/dst' (required)
        :param str src_storage_name: Source storage name
        :param str dest_storage_name: Destination storage name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src_path', 'dest_path', 'src_storage_name', 'dest_storage_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method move_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src_path' is set
        if ('src_path' not in params or
                params['src_path'] is None):
            raise ValueError("Missing the required parameter `src_path` when calling `move_folder`")  # noqa: E501
        # verify the required parameter 'dest_path' is set
        if ('dest_path' not in params or
                params['dest_path'] is None):
            raise ValueError("Missing the required parameter `dest_path` when calling `move_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'src_path' in params:
            path_params['srcPath'] = params['src_path']  # noqa: E501

        query_params = []
        if 'dest_path' in params:
            query_params.append(('destPath', params['dest_path']))  # noqa: E501
        if 'src_storage_name' in params:
            query_params.append(('srcStorageName', params['src_storage_name']))  # noqa: E501
        if 'dest_storage_name' in params:
            query_params.append(('destStorageName', params['dest_storage_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/folder/move/{srcPath}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def object_exists(self, path, **kwargs):  # noqa: E501
        """Check if file or folder exists  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.object_exists(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: File or folder path e.g. '/file.ext' or '/folder' (required)
        :param str storage_name: Storage name
        :param str version_id: File version ID
        :return: ObjectExist
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.object_exists_with_http_info(path, **kwargs)  # noqa: E501
        else:
            (data) = self.object_exists_with_http_info(path, **kwargs)  # noqa: E501
            return data

    def object_exists_with_http_info(self, path, **kwargs):  # noqa: E501
        """Check if file or folder exists  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.object_exists_with_http_info(path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: File or folder path e.g. '/file.ext' or '/folder' (required)
        :param str storage_name: Storage name
        :param str version_id: File version ID
        :return: ObjectExist
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage_name', 'version_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method object_exists" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `object_exists`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))  # noqa: E501
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/exist/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ObjectExist',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_create_search_context(self, **kwargs):  # noqa: E501
        """Create new search context.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_create_search_context(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str detector: The image features detector.
        :param str matching_algorithm: The matching algorithm.
        :param str folder: The folder.
        :param str storage: The storage.
        :return: SearchContextStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_create_search_context_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_create_search_context_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_create_search_context_with_http_info(self, **kwargs):  # noqa: E501
        """Create new search context.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_create_search_context_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str detector: The image features detector.
        :param str matching_algorithm: The matching algorithm.
        :param str folder: The folder.
        :param str storage: The storage.
        :return: SearchContextStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['detector', 'matching_algorithm', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_create_search_context" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'detector' in params:
            query_params.append(('detector', params['detector']))  # noqa: E501
        if 'matching_algorithm' in params:
            query_params.append(('matchingAlgorithm', params['matching_algorithm']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchContextStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_bmp(self, image_data, bits_per_pixel, horizontal_resolution, vertical_resolution, **kwargs):  # noqa: E501
        """Update parameters of BMP image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_bmp(image_data, bits_per_pixel, horizontal_resolution, vertical_resolution, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int bits_per_pixel: Color depth. (required)
        :param int horizontal_resolution: New horizontal resolution. (required)
        :param int vertical_resolution: New vertical resolution. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_bmp_with_http_info(image_data, bits_per_pixel, horizontal_resolution, vertical_resolution, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_bmp_with_http_info(image_data, bits_per_pixel, horizontal_resolution, vertical_resolution, **kwargs)  # noqa: E501
            return data

    def post_image_bmp_with_http_info(self, image_data, bits_per_pixel, horizontal_resolution, vertical_resolution, **kwargs):  # noqa: E501
        """Update parameters of BMP image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_bmp_with_http_info(image_data, bits_per_pixel, horizontal_resolution, vertical_resolution, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int bits_per_pixel: Color depth. (required)
        :param int horizontal_resolution: New horizontal resolution. (required)
        :param int vertical_resolution: New vertical resolution. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'bits_per_pixel', 'horizontal_resolution', 'vertical_resolution', 'from_scratch', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_bmp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_bmp`")  # noqa: E501
        # verify the required parameter 'bits_per_pixel' is set
        if ('bits_per_pixel' not in params or
                params['bits_per_pixel'] is None):
            raise ValueError("Missing the required parameter `bits_per_pixel` when calling `post_image_bmp`")  # noqa: E501
        # verify the required parameter 'horizontal_resolution' is set
        if ('horizontal_resolution' not in params or
                params['horizontal_resolution'] is None):
            raise ValueError("Missing the required parameter `horizontal_resolution` when calling `post_image_bmp`")  # noqa: E501
        # verify the required parameter 'vertical_resolution' is set
        if ('vertical_resolution' not in params or
                params['vertical_resolution'] is None):
            raise ValueError("Missing the required parameter `vertical_resolution` when calling `post_image_bmp`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'bits_per_pixel' in params:
            query_params.append(('bitsPerPixel', params['bits_per_pixel']))  # noqa: E501
        if 'horizontal_resolution' in params:
            query_params.append(('horizontalResolution', params['horizontal_resolution']))  # noqa: E501
        if 'vertical_resolution' in params:
            query_params.append(('verticalResolution', params['vertical_resolution']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/bmp', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_crop(self, image_data, format, x, y, width, height, **kwargs):  # noqa: E501
        """Crop an image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_crop(image_data, format, x, y, width, height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str format: Resulting image format. (required)
        :param int x: X position of start point for cropping rectangle. (required)
        :param int y: Y position of start point for cropping rectangle. (required)
        :param int width: Width of cropping rectangle. (required)
        :param int height: Height of cropping rectangle. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_crop_with_http_info(image_data, format, x, y, width, height, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_crop_with_http_info(image_data, format, x, y, width, height, **kwargs)  # noqa: E501
            return data

    def post_image_crop_with_http_info(self, image_data, format, x, y, width, height, **kwargs):  # noqa: E501
        """Crop an image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_crop_with_http_info(image_data, format, x, y, width, height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str format: Resulting image format. (required)
        :param int x: X position of start point for cropping rectangle. (required)
        :param int y: Y position of start point for cropping rectangle. (required)
        :param int width: Width of cropping rectangle. (required)
        :param int height: Height of cropping rectangle. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'format', 'x', 'y', 'width', 'height', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_crop" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_crop`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `post_image_crop`")  # noqa: E501
        # verify the required parameter 'x' is set
        if ('x' not in params or
                params['x'] is None):
            raise ValueError("Missing the required parameter `x` when calling `post_image_crop`")  # noqa: E501
        # verify the required parameter 'y' is set
        if ('y' not in params or
                params['y'] is None):
            raise ValueError("Missing the required parameter `y` when calling `post_image_crop`")  # noqa: E501
        # verify the required parameter 'width' is set
        if ('width' not in params or
                params['width'] is None):
            raise ValueError("Missing the required parameter `width` when calling `post_image_crop`")  # noqa: E501
        # verify the required parameter 'height' is set
        if ('height' not in params or
                params['height'] is None):
            raise ValueError("Missing the required parameter `height` when calling `post_image_crop`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'x' in params:
            query_params.append(('x', params['x']))  # noqa: E501
        if 'y' in params:
            query_params.append(('y', params['y']))  # noqa: E501
        if 'width' in params:
            query_params.append(('width', params['width']))  # noqa: E501
        if 'height' in params:
            query_params.append(('height', params['height']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/crop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_emf(self, image_data, bk_color, page_width, page_height, border_x, border_y, **kwargs):  # noqa: E501
        """Process existing EMF imaging using given parameters. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_emf(image_data, bk_color, page_width, page_height, border_x, border_y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str bk_color: Color of the background. (required)
        :param int page_width: Width of the page. (required)
        :param int page_height: Height of the page. (required)
        :param int border_x: Border width. (required)
        :param int border_y: Border height. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :param str format: Export format (PNG is the default one).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_emf_with_http_info(image_data, bk_color, page_width, page_height, border_x, border_y, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_emf_with_http_info(image_data, bk_color, page_width, page_height, border_x, border_y, **kwargs)  # noqa: E501
            return data

    def post_image_emf_with_http_info(self, image_data, bk_color, page_width, page_height, border_x, border_y, **kwargs):  # noqa: E501
        """Process existing EMF imaging using given parameters. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_emf_with_http_info(image_data, bk_color, page_width, page_height, border_x, border_y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str bk_color: Color of the background. (required)
        :param int page_width: Width of the page. (required)
        :param int page_height: Height of the page. (required)
        :param int border_x: Border width. (required)
        :param int border_y: Border height. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :param str format: Export format (PNG is the default one).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'bk_color', 'page_width', 'page_height', 'border_x', 'border_y', 'from_scratch', 'out_path', 'storage', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_emf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_emf`")  # noqa: E501
        # verify the required parameter 'bk_color' is set
        if ('bk_color' not in params or
                params['bk_color'] is None):
            raise ValueError("Missing the required parameter `bk_color` when calling `post_image_emf`")  # noqa: E501
        # verify the required parameter 'page_width' is set
        if ('page_width' not in params or
                params['page_width'] is None):
            raise ValueError("Missing the required parameter `page_width` when calling `post_image_emf`")  # noqa: E501
        # verify the required parameter 'page_height' is set
        if ('page_height' not in params or
                params['page_height'] is None):
            raise ValueError("Missing the required parameter `page_height` when calling `post_image_emf`")  # noqa: E501
        # verify the required parameter 'border_x' is set
        if ('border_x' not in params or
                params['border_x'] is None):
            raise ValueError("Missing the required parameter `border_x` when calling `post_image_emf`")  # noqa: E501
        # verify the required parameter 'border_y' is set
        if ('border_y' not in params or
                params['border_y'] is None):
            raise ValueError("Missing the required parameter `border_y` when calling `post_image_emf`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'bk_color' in params:
            query_params.append(('bkColor', params['bk_color']))  # noqa: E501
        if 'page_width' in params:
            query_params.append(('pageWidth', params['page_width']))  # noqa: E501
        if 'page_height' in params:
            query_params.append(('pageHeight', params['page_height']))  # noqa: E501
        if 'border_x' in params:
            query_params.append(('borderX', params['border_x']))  # noqa: E501
        if 'border_y' in params:
            query_params.append(('borderY', params['border_y']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/emf', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_frame(self, image_data, frame_id, **kwargs):  # noqa: E501
        """Get separate frame from existing TIFF image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_frame(image_data, frame_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int frame_id: Number of a frame. (required)
        :param int new_width: New width.
        :param int new_height: New height.
        :param int x: X position of start point for cropping rectangle.
        :param int y: Y position of start point for cropping rectangle.
        :param int rect_width: Width of cropping rectangle.
        :param int rect_height: Height of cropping rectangle.
        :param str rotate_flip_method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). Default is RotateNoneFlipNone.
        :param bool save_other_frames: If result will include all other frames or just a specified frame.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_frame_with_http_info(image_data, frame_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_frame_with_http_info(image_data, frame_id, **kwargs)  # noqa: E501
            return data

    def post_image_frame_with_http_info(self, image_data, frame_id, **kwargs):  # noqa: E501
        """Get separate frame from existing TIFF image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_frame_with_http_info(image_data, frame_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int frame_id: Number of a frame. (required)
        :param int new_width: New width.
        :param int new_height: New height.
        :param int x: X position of start point for cropping rectangle.
        :param int y: Y position of start point for cropping rectangle.
        :param int rect_width: Width of cropping rectangle.
        :param int rect_height: Height of cropping rectangle.
        :param str rotate_flip_method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). Default is RotateNoneFlipNone.
        :param bool save_other_frames: If result will include all other frames or just a specified frame.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'frame_id', 'new_width', 'new_height', 'x', 'y', 'rect_width', 'rect_height', 'rotate_flip_method', 'save_other_frames', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_frame" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_frame`")  # noqa: E501
        # verify the required parameter 'frame_id' is set
        if ('frame_id' not in params or
                params['frame_id'] is None):
            raise ValueError("Missing the required parameter `frame_id` when calling `post_image_frame`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'frame_id' in params:
            path_params['frameId'] = params['frame_id']  # noqa: E501

        query_params = []
        if 'new_width' in params:
            query_params.append(('newWidth', params['new_width']))  # noqa: E501
        if 'new_height' in params:
            query_params.append(('newHeight', params['new_height']))  # noqa: E501
        if 'x' in params:
            query_params.append(('x', params['x']))  # noqa: E501
        if 'y' in params:
            query_params.append(('y', params['y']))  # noqa: E501
        if 'rect_width' in params:
            query_params.append(('rectWidth', params['rect_width']))  # noqa: E501
        if 'rect_height' in params:
            query_params.append(('rectHeight', params['rect_height']))  # noqa: E501
        if 'rotate_flip_method' in params:
            query_params.append(('rotateFlipMethod', params['rotate_flip_method']))  # noqa: E501
        if 'save_other_frames' in params:
            query_params.append(('saveOtherFrames', params['save_other_frames']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/frames/{frameId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_frame_properties(self, image_data, frame_id, **kwargs):  # noqa: E501
        """Get separate frame properties of existing TIFF image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_frame_properties(image_data, frame_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int frame_id: Number of a frame. (required)
        :return: ImagingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_frame_properties_with_http_info(image_data, frame_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_frame_properties_with_http_info(image_data, frame_id, **kwargs)  # noqa: E501
            return data

    def post_image_frame_properties_with_http_info(self, image_data, frame_id, **kwargs):  # noqa: E501
        """Get separate frame properties of existing TIFF image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_frame_properties_with_http_info(image_data, frame_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int frame_id: Number of a frame. (required)
        :return: ImagingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'frame_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_frame_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_frame_properties`")  # noqa: E501
        # verify the required parameter 'frame_id' is set
        if ('frame_id' not in params or
                params['frame_id'] is None):
            raise ValueError("Missing the required parameter `frame_id` when calling `post_image_frame_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'frame_id' in params:
            path_params['frameId'] = params['frame_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/frames/{frameId}/properties', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImagingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_gif(self, image_data, **kwargs):  # noqa: E501
        """Update parameters of GIF image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_gif(image_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int background_color_index: Index of the background color.
        :param int color_resolution: Color resolution.
        :param bool has_trailer: Specifies if image has trailer.
        :param bool interlaced: Specifies if image is interlaced.
        :param bool is_palette_sorted: Specifies if palette is sorted.
        :param int pixel_aspect_ratio: Pixel aspect ratio.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_gif_with_http_info(image_data, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_gif_with_http_info(image_data, **kwargs)  # noqa: E501
            return data

    def post_image_gif_with_http_info(self, image_data, **kwargs):  # noqa: E501
        """Update parameters of GIF image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_gif_with_http_info(image_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int background_color_index: Index of the background color.
        :param int color_resolution: Color resolution.
        :param bool has_trailer: Specifies if image has trailer.
        :param bool interlaced: Specifies if image is interlaced.
        :param bool is_palette_sorted: Specifies if palette is sorted.
        :param int pixel_aspect_ratio: Pixel aspect ratio.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'background_color_index', 'color_resolution', 'has_trailer', 'interlaced', 'is_palette_sorted', 'pixel_aspect_ratio', 'from_scratch', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_gif" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_gif`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'background_color_index' in params:
            query_params.append(('backgroundColorIndex', params['background_color_index']))  # noqa: E501
        if 'color_resolution' in params:
            query_params.append(('colorResolution', params['color_resolution']))  # noqa: E501
        if 'has_trailer' in params:
            query_params.append(('hasTrailer', params['has_trailer']))  # noqa: E501
        if 'interlaced' in params:
            query_params.append(('interlaced', params['interlaced']))  # noqa: E501
        if 'is_palette_sorted' in params:
            query_params.append(('isPaletteSorted', params['is_palette_sorted']))  # noqa: E501
        if 'pixel_aspect_ratio' in params:
            query_params.append(('pixelAspectRatio', params['pixel_aspect_ratio']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/gif', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_jpeg2000(self, image_data, comment, **kwargs):  # noqa: E501
        """Update parameters of JPEG2000 image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_jpeg2000(image_data, comment, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str comment: The comment. (required)
        :param str codec: The codec.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_jpeg2000_with_http_info(image_data, comment, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_jpeg2000_with_http_info(image_data, comment, **kwargs)  # noqa: E501
            return data

    def post_image_jpeg2000_with_http_info(self, image_data, comment, **kwargs):  # noqa: E501
        """Update parameters of JPEG2000 image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_jpeg2000_with_http_info(image_data, comment, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str comment: The comment. (required)
        :param str codec: The codec.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'comment', 'codec', 'from_scratch', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_jpeg2000" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_jpeg2000`")  # noqa: E501
        # verify the required parameter 'comment' is set
        if ('comment' not in params or
                params['comment'] is None):
            raise ValueError("Missing the required parameter `comment` when calling `post_image_jpeg2000`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'comment' in params:
            query_params.append(('comment', params['comment']))  # noqa: E501
        if 'codec' in params:
            query_params.append(('codec', params['codec']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/jpg2000', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_jpg(self, image_data, **kwargs):  # noqa: E501
        """Update parameters of JPEG image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_jpg(image_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int quality: Quality of an image from 0 to 100. Default is 75.
        :param str compression_type: Compression type.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_jpg_with_http_info(image_data, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_jpg_with_http_info(image_data, **kwargs)  # noqa: E501
            return data

    def post_image_jpg_with_http_info(self, image_data, **kwargs):  # noqa: E501
        """Update parameters of JPEG image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_jpg_with_http_info(image_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int quality: Quality of an image from 0 to 100. Default is 75.
        :param str compression_type: Compression type.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'quality', 'compression_type', 'from_scratch', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_jpg" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_jpg`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'quality' in params:
            query_params.append(('quality', params['quality']))  # noqa: E501
        if 'compression_type' in params:
            query_params.append(('compressionType', params['compression_type']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/jpg', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_properties(self, image_data, **kwargs):  # noqa: E501
        """Get properties of an image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_properties(image_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :return: ImagingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_properties_with_http_info(image_data, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_properties_with_http_info(image_data, **kwargs)  # noqa: E501
            return data

    def post_image_properties_with_http_info(self, image_data, **kwargs):  # noqa: E501
        """Get properties of an image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_properties_with_http_info(image_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :return: ImagingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        # TODO: Why codegen want to set Content-Type to application/json, if we are sending file?
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/properties', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImagingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_psd(self, image_data, **kwargs):  # noqa: E501
        """Update parameters of PSD image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_psd(image_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int channels_count: Count of color channels.
        :param str compression_method: Compression method.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_psd_with_http_info(image_data, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_psd_with_http_info(image_data, **kwargs)  # noqa: E501
            return data

    def post_image_psd_with_http_info(self, image_data, **kwargs):  # noqa: E501
        """Update parameters of PSD image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_psd_with_http_info(image_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param int channels_count: Count of color channels.
        :param str compression_method: Compression method.
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'channels_count', 'compression_method', 'from_scratch', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_psd" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_psd`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'channels_count' in params:
            query_params.append(('channelsCount', params['channels_count']))  # noqa: E501
        if 'compression_method' in params:
            query_params.append(('compressionMethod', params['compression_method']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/psd', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_resize(self, image_data, format, new_width, new_height, **kwargs):  # noqa: E501
        """Resize an image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_resize(image_data, format, new_width, new_height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str format: Resulting image format. (required)
        :param int new_width: New width. (required)
        :param int new_height: New height. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_resize_with_http_info(image_data, format, new_width, new_height, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_resize_with_http_info(image_data, format, new_width, new_height, **kwargs)  # noqa: E501
            return data

    def post_image_resize_with_http_info(self, image_data, format, new_width, new_height, **kwargs):  # noqa: E501
        """Resize an image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_resize_with_http_info(image_data, format, new_width, new_height, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str format: Resulting image format. (required)
        :param int new_width: New width. (required)
        :param int new_height: New height. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'format', 'new_width', 'new_height', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_resize" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_resize`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `post_image_resize`")  # noqa: E501
        # verify the required parameter 'new_width' is set
        if ('new_width' not in params or
                params['new_width'] is None):
            raise ValueError("Missing the required parameter `new_width` when calling `post_image_resize`")  # noqa: E501
        # verify the required parameter 'new_height' is set
        if ('new_height' not in params or
                params['new_height'] is None):
            raise ValueError("Missing the required parameter `new_height` when calling `post_image_resize`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'new_width' in params:
            query_params.append(('newWidth', params['new_width']))  # noqa: E501
        if 'new_height' in params:
            query_params.append(('newHeight', params['new_height']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/resize', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_rotate_flip(self, image_data, format, method, **kwargs):  # noqa: E501
        """Rotate and/or flip an image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_rotate_flip(image_data, format, method, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str format: Resulting image format. (required)
        :param str method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_rotate_flip_with_http_info(image_data, format, method, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_rotate_flip_with_http_info(image_data, format, method, **kwargs)  # noqa: E501
            return data

    def post_image_rotate_flip_with_http_info(self, image_data, format, method, **kwargs):  # noqa: E501
        """Rotate and/or flip an image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_rotate_flip_with_http_info(image_data, format, method, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str format: Resulting image format. (required)
        :param str method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'format', 'method', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_rotate_flip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_rotate_flip`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `post_image_rotate_flip`")  # noqa: E501
        # verify the required parameter 'method' is set
        if ('method' not in params or
                params['method'] is None):
            raise ValueError("Missing the required parameter `method` when calling `post_image_rotate_flip`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'method' in params:
            query_params.append(('method', params['method']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/rotateflip', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_save_as(self, image_data, format, **kwargs):  # noqa: E501
        """Export existing image to another format. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.               # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_save_as(image_data, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str format: Resulting image format. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_save_as_with_http_info(image_data, format, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_save_as_with_http_info(image_data, format, **kwargs)  # noqa: E501
            return data

    def post_image_save_as_with_http_info(self, image_data, format, **kwargs):  # noqa: E501
        """Export existing image to another format. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.               # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_save_as_with_http_info(image_data, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str format: Resulting image format. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'format', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_save_as" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_save_as`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `post_image_save_as`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/saveAs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_tiff(self, image_data, compression, resolution_unit, bit_depth, **kwargs):  # noqa: E501
        """Update parameters of TIFF image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_tiff(image_data, compression, resolution_unit, bit_depth, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str compression: Compression. (required)
        :param str resolution_unit: New resolution unit. (required)
        :param int bit_depth: Bit depth. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param float horizontal_resolution: New horizontal resolution.
        :param float vertical_resolution: New verstical resolution.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_tiff_with_http_info(image_data, compression, resolution_unit, bit_depth, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_tiff_with_http_info(image_data, compression, resolution_unit, bit_depth, **kwargs)  # noqa: E501
            return data

    def post_image_tiff_with_http_info(self, image_data, compression, resolution_unit, bit_depth, **kwargs):  # noqa: E501
        """Update parameters of TIFF image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_tiff_with_http_info(image_data, compression, resolution_unit, bit_depth, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str compression: Compression. (required)
        :param str resolution_unit: New resolution unit. (required)
        :param int bit_depth: Bit depth. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param float horizontal_resolution: New horizontal resolution.
        :param float vertical_resolution: New verstical resolution.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'compression', 'resolution_unit', 'bit_depth', 'from_scratch', 'horizontal_resolution', 'vertical_resolution', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_tiff" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_tiff`")  # noqa: E501
        # verify the required parameter 'compression' is set
        if ('compression' not in params or
                params['compression'] is None):
            raise ValueError("Missing the required parameter `compression` when calling `post_image_tiff`")  # noqa: E501
        # verify the required parameter 'resolution_unit' is set
        if ('resolution_unit' not in params or
                params['resolution_unit'] is None):
            raise ValueError("Missing the required parameter `resolution_unit` when calling `post_image_tiff`")  # noqa: E501
        # verify the required parameter 'bit_depth' is set
        if ('bit_depth' not in params or
                params['bit_depth'] is None):
            raise ValueError("Missing the required parameter `bit_depth` when calling `post_image_tiff`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'compression' in params:
            query_params.append(('compression', params['compression']))  # noqa: E501
        if 'resolution_unit' in params:
            query_params.append(('resolutionUnit', params['resolution_unit']))  # noqa: E501
        if 'bit_depth' in params:
            query_params.append(('bitDepth', params['bit_depth']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'horizontal_resolution' in params:
            query_params.append(('horizontalResolution', params['horizontal_resolution']))  # noqa: E501
        if 'vertical_resolution' in params:
            query_params.append(('verticalResolution', params['vertical_resolution']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/tiff', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_update(self, image_data, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, **kwargs):  # noqa: E501
        """Perform scaling, cropping and flipping of an image in a single request. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.               # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_update(image_data, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str format: Resulting image format. (required)
        :param int new_width: New width of the scaled image. (required)
        :param int new_height: New height of the scaled image. (required)
        :param int x: X position of start point for cropping rectangle. (required)
        :param int y: Y position of start point for cropping rectangle. (required)
        :param int rect_width: Width of cropping rectangle. (required)
        :param int rect_height: Height of cropping rectangle. (required)
        :param str rotate_flip_method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). Default is RotateNoneFlipNone. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_update_with_http_info(image_data, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_update_with_http_info(image_data, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, **kwargs)  # noqa: E501
            return data

    def post_image_update_with_http_info(self, image_data, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, **kwargs):  # noqa: E501
        """Perform scaling, cropping and flipping of an image in a single request. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.               # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_update_with_http_info(image_data, format, new_width, new_height, x, y, rect_width, rect_height, rotate_flip_method, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str format: Resulting image format. (required)
        :param int new_width: New width of the scaled image. (required)
        :param int new_height: New height of the scaled image. (required)
        :param int x: X position of start point for cropping rectangle. (required)
        :param int y: Y position of start point for cropping rectangle. (required)
        :param int rect_width: Width of cropping rectangle. (required)
        :param int rect_height: Height of cropping rectangle. (required)
        :param str rotate_flip_method: RotateFlip method (Rotate180FlipNone, Rotate180FlipX, Rotate180FlipXY, Rotate180FlipY, Rotate270FlipNone, Rotate270FlipX, Rotate270FlipXY, Rotate270FlipY, Rotate90FlipNone, Rotate90FlipX, Rotate90FlipXY, Rotate90FlipY, RotateNoneFlipNone, RotateNoneFlipX, RotateNoneFlipXY, RotateNoneFlipY). Default is RotateNoneFlipNone. (required)
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'format', 'new_width', 'new_height', 'x', 'y', 'rect_width', 'rect_height', 'rotate_flip_method', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_update`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `post_image_update`")  # noqa: E501
        # verify the required parameter 'new_width' is set
        if ('new_width' not in params or
                params['new_width'] is None):
            raise ValueError("Missing the required parameter `new_width` when calling `post_image_update`")  # noqa: E501
        # verify the required parameter 'new_height' is set
        if ('new_height' not in params or
                params['new_height'] is None):
            raise ValueError("Missing the required parameter `new_height` when calling `post_image_update`")  # noqa: E501
        # verify the required parameter 'x' is set
        if ('x' not in params or
                params['x'] is None):
            raise ValueError("Missing the required parameter `x` when calling `post_image_update`")  # noqa: E501
        # verify the required parameter 'y' is set
        if ('y' not in params or
                params['y'] is None):
            raise ValueError("Missing the required parameter `y` when calling `post_image_update`")  # noqa: E501
        # verify the required parameter 'rect_width' is set
        if ('rect_width' not in params or
                params['rect_width'] is None):
            raise ValueError("Missing the required parameter `rect_width` when calling `post_image_update`")  # noqa: E501
        # verify the required parameter 'rect_height' is set
        if ('rect_height' not in params or
                params['rect_height'] is None):
            raise ValueError("Missing the required parameter `rect_height` when calling `post_image_update`")  # noqa: E501
        # verify the required parameter 'rotate_flip_method' is set
        if ('rotate_flip_method' not in params or
                params['rotate_flip_method'] is None):
            raise ValueError("Missing the required parameter `rotate_flip_method` when calling `post_image_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'new_width' in params:
            query_params.append(('newWidth', params['new_width']))  # noqa: E501
        if 'new_height' in params:
            query_params.append(('newHeight', params['new_height']))  # noqa: E501
        if 'x' in params:
            query_params.append(('x', params['x']))  # noqa: E501
        if 'y' in params:
            query_params.append(('y', params['y']))  # noqa: E501
        if 'rect_width' in params:
            query_params.append(('rectWidth', params['rect_width']))  # noqa: E501
        if 'rect_height' in params:
            query_params.append(('rectHeight', params['rect_height']))  # noqa: E501
        if 'rotate_flip_method' in params:
            query_params.append(('rotateFlipMethod', params['rotate_flip_method']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/updateImage', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_web_p(self, image_data, loss_less, quality, anim_loop_count, anim_background_color, **kwargs):  # noqa: E501
        """Update parameters of WEBP image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_web_p(image_data, loss_less, quality, anim_loop_count, anim_background_color, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param bool loss_less: If WEBP is lossless. (required)
        :param int quality: Quality. (required)
        :param int anim_loop_count: The animation loop count. (required)
        :param str anim_background_color: Color of the animation background. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_web_p_with_http_info(image_data, loss_less, quality, anim_loop_count, anim_background_color, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_web_p_with_http_info(image_data, loss_less, quality, anim_loop_count, anim_background_color, **kwargs)  # noqa: E501
            return data

    def post_image_web_p_with_http_info(self, image_data, loss_less, quality, anim_loop_count, anim_background_color, **kwargs):  # noqa: E501
        """Update parameters of WEBP image. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_web_p_with_http_info(image_data, loss_less, quality, anim_loop_count, anim_background_color, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param bool loss_less: If WEBP is lossless. (required)
        :param int quality: Quality. (required)
        :param int anim_loop_count: The animation loop count. (required)
        :param str anim_background_color: Color of the animation background. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'loss_less', 'quality', 'anim_loop_count', 'anim_background_color', 'from_scratch', 'out_path', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_web_p" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_web_p`")  # noqa: E501
        # verify the required parameter 'loss_less' is set
        if ('loss_less' not in params or
                params['loss_less'] is None):
            raise ValueError("Missing the required parameter `loss_less` when calling `post_image_web_p`")  # noqa: E501
        # verify the required parameter 'quality' is set
        if ('quality' not in params or
                params['quality'] is None):
            raise ValueError("Missing the required parameter `quality` when calling `post_image_web_p`")  # noqa: E501
        # verify the required parameter 'anim_loop_count' is set
        if ('anim_loop_count' not in params or
                params['anim_loop_count'] is None):
            raise ValueError("Missing the required parameter `anim_loop_count` when calling `post_image_web_p`")  # noqa: E501
        # verify the required parameter 'anim_background_color' is set
        if ('anim_background_color' not in params or
                params['anim_background_color'] is None):
            raise ValueError("Missing the required parameter `anim_background_color` when calling `post_image_web_p`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'loss_less' in params:
            query_params.append(('lossLess', params['loss_less']))  # noqa: E501
        if 'quality' in params:
            query_params.append(('quality', params['quality']))  # noqa: E501
        if 'anim_loop_count' in params:
            query_params.append(('animLoopCount', params['anim_loop_count']))  # noqa: E501
        if 'anim_background_color' in params:
            query_params.append(('animBackgroundColor', params['anim_background_color']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/webp', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_image_wmf(self, image_data, bk_color, page_width, page_height, border_x, border_y, **kwargs):  # noqa: E501
        """Process existing WMF image using given parameters. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_wmf(image_data, bk_color, page_width, page_height, border_x, border_y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str bk_color: Color of the background. (required)
        :param int page_width: Width of the page. (required)
        :param int page_height: Height of the page. (required)
        :param int border_x: Border width. (required)
        :param int border_y: Border height. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :param str format: Export format (PNG is the default one).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_image_wmf_with_http_info(image_data, bk_color, page_width, page_height, border_x, border_y, **kwargs)  # noqa: E501
        else:
            (data) = self.post_image_wmf_with_http_info(image_data, bk_color, page_width, page_height, border_x, border_y, **kwargs)  # noqa: E501
            return data

    def post_image_wmf_with_http_info(self, image_data, bk_color, page_width, page_height, border_x, border_y, **kwargs):  # noqa: E501
        """Process existing WMF image using given parameters. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_image_wmf_with_http_info(image_data, bk_color, page_width, page_height, border_x, border_y, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str bk_color: Color of the background. (required)
        :param int page_width: Width of the page. (required)
        :param int page_height: Height of the page. (required)
        :param int border_x: Border width. (required)
        :param int border_y: Border height. (required)
        :param bool from_scratch: Specifies where additional parameters we do not support should be taken from. If this is true – they will be taken from default values for standard image, if it is false – they will be saved from current image. Default is false.
        :param str out_path: Path to updated file (if this is empty, response contains streamed image).
        :param str storage: Your Aspose Cloud Storage name.
        :param str format: Export format (PNG is the default one).
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'bk_color', 'page_width', 'page_height', 'border_x', 'border_y', 'from_scratch', 'out_path', 'storage', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_image_wmf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_image_wmf`")  # noqa: E501
        # verify the required parameter 'bk_color' is set
        if ('bk_color' not in params or
                params['bk_color'] is None):
            raise ValueError("Missing the required parameter `bk_color` when calling `post_image_wmf`")  # noqa: E501
        # verify the required parameter 'page_width' is set
        if ('page_width' not in params or
                params['page_width'] is None):
            raise ValueError("Missing the required parameter `page_width` when calling `post_image_wmf`")  # noqa: E501
        # verify the required parameter 'page_height' is set
        if ('page_height' not in params or
                params['page_height'] is None):
            raise ValueError("Missing the required parameter `page_height` when calling `post_image_wmf`")  # noqa: E501
        # verify the required parameter 'border_x' is set
        if ('border_x' not in params or
                params['border_x'] is None):
            raise ValueError("Missing the required parameter `border_x` when calling `post_image_wmf`")  # noqa: E501
        # verify the required parameter 'border_y' is set
        if ('border_y' not in params or
                params['border_y'] is None):
            raise ValueError("Missing the required parameter `border_y` when calling `post_image_wmf`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'bk_color' in params:
            query_params.append(('bkColor', params['bk_color']))  # noqa: E501
        if 'page_width' in params:
            query_params.append(('pageWidth', params['page_width']))  # noqa: E501
        if 'page_height' in params:
            query_params.append(('pageHeight', params['page_height']))  # noqa: E501
        if 'border_x' in params:
            query_params.append(('borderX', params['border_x']))  # noqa: E501
        if 'border_y' in params:
            query_params.append(('borderY', params['border_y']))  # noqa: E501
        if 'from_scratch' in params:
            query_params.append(('fromScratch', params['from_scratch']))  # noqa: E501
        if 'out_path' in params:
            query_params.append(('outPath', params['out_path']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/wmf', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_search_context_add_image(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Add image and images features to search context. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_search_context_add_image(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: Search context identifier. (required)
        :param str image_id: Image identifier. (required)
        :param file image_data: Input image
        :param str folder: Folder.
        :param str storage: Storage
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_search_context_add_image_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_search_context_add_image_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
            return data

    def post_search_context_add_image_with_http_info(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Add image and images features to search context. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_search_context_add_image_with_http_info(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: Search context identifier. (required)
        :param str image_id: Image identifier. (required)
        :param file image_data: Input image
        :param str folder: Folder.
        :param str storage: Storage
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'image_id', 'image_data', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_search_context_add_image" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `post_search_context_add_image`")  # noqa: E501
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params or
                params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `post_search_context_add_image`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'image_id' in params:
            query_params.append(('imageId', params['image_id']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/image', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_search_context_add_tag(self, image_data, search_context_id, tag_name, **kwargs):  # noqa: E501
        """Add tag and reference image to search context. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_search_context_add_tag(image_data, search_context_id, tag_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str search_context_id: The search context identifier. (required)
        :param str tag_name: The tag. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_search_context_add_tag_with_http_info(image_data, search_context_id, tag_name, **kwargs)  # noqa: E501
        else:
            (data) = self.post_search_context_add_tag_with_http_info(image_data, search_context_id, tag_name, **kwargs)  # noqa: E501
            return data

    def post_search_context_add_tag_with_http_info(self, image_data, search_context_id, tag_name, **kwargs):  # noqa: E501
        """Add tag and reference image to search context. Image data is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_search_context_add_tag_with_http_info(image_data, search_context_id, tag_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image_data: Input image (required)
        :param str search_context_id: The search context identifier. (required)
        :param str tag_name: The tag. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_data', 'search_context_id', 'tag_name', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_search_context_add_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_data' is set
        if ('image_data' not in params or
                params['image_data'] is None):
            raise ValueError("Missing the required parameter `image_data` when calling `post_search_context_add_tag`")  # noqa: E501
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `post_search_context_add_tag`")  # noqa: E501
        # verify the required parameter 'tag_name' is set
        if ('tag_name' not in params or
                params['tag_name'] is None):
            raise ValueError("Missing the required parameter `tag_name` when calling `post_search_context_add_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'tag_name' in params:
            query_params.append(('tagName', params['tag_name']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/addTag', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_search_context_compare_images(self, search_context_id, image_id1, **kwargs):  # noqa: E501
        """Compare two images. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_search_context_compare_images(search_context_id, image_id1, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str image_id1: The first image Id in storage. (required)
        :param file image_data: Input image
        :param str image_id2: The second image Idin storage or null(if image loading in request).
        :param str folder: The folder.
        :param str storage: The storage.
        :return: SearchResultsSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_search_context_compare_images_with_http_info(search_context_id, image_id1, **kwargs)  # noqa: E501
        else:
            (data) = self.post_search_context_compare_images_with_http_info(search_context_id, image_id1, **kwargs)  # noqa: E501
            return data

    def post_search_context_compare_images_with_http_info(self, search_context_id, image_id1, **kwargs):  # noqa: E501
        """Compare two images. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_search_context_compare_images_with_http_info(search_context_id, image_id1, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str image_id1: The first image Id in storage. (required)
        :param file image_data: Input image
        :param str image_id2: The second image Idin storage or null(if image loading in request).
        :param str folder: The folder.
        :param str storage: The storage.
        :return: SearchResultsSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'image_id1', 'image_data', 'image_id2', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_search_context_compare_images" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `post_search_context_compare_images`")  # noqa: E501
        # verify the required parameter 'image_id1' is set
        if ('image_id1' not in params or
                params['image_id1'] is None):
            raise ValueError("Missing the required parameter `image_id1` when calling `post_search_context_compare_images`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'image_id1' in params:
            query_params.append(('imageId1', params['image_id1']))  # noqa: E501
        if 'image_id2' in params:
            query_params.append(('imageId2', params['image_id2']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/compare', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchResultsSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_search_context_extract_image_features(self, search_context_id, **kwargs):  # noqa: E501
        """Extract images features and add them to search context. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_search_context_extract_image_features(search_context_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param file image_data: Input image
        :param str image_id: The image identifier.
        :param str images_folder: Images folder.
        :param str folder: The folder.
        :param str storage: The storage.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_search_context_extract_image_features_with_http_info(search_context_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_search_context_extract_image_features_with_http_info(search_context_id, **kwargs)  # noqa: E501
            return data

    def post_search_context_extract_image_features_with_http_info(self, search_context_id, **kwargs):  # noqa: E501
        """Extract images features and add them to search context. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_search_context_extract_image_features_with_http_info(search_context_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param file image_data: Input image
        :param str image_id: The image identifier.
        :param str images_folder: Images folder.
        :param str folder: The folder.
        :param str storage: The storage.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'image_data', 'image_id', 'images_folder', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_search_context_extract_image_features" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `post_search_context_extract_image_features`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'image_id' in params:
            query_params.append(('imageId', params['image_id']))  # noqa: E501
        if 'images_folder' in params:
            query_params.append(('imagesFolder', params['images_folder']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/features', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_search_context_find_by_tags(self, tags, search_context_id, similarity_threshold, max_count, **kwargs):  # noqa: E501
        """Find images by tags. Tags JSON string is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_search_context_find_by_tags(tags, search_context_id, similarity_threshold, max_count, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tags: Tags array for searching (required)
        :param str search_context_id: The search context identifier. (required)
        :param float similarity_threshold: The similarity threshold. (required)
        :param int max_count: The maximum count. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: SearchResultsSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_search_context_find_by_tags_with_http_info(tags, search_context_id, similarity_threshold, max_count, **kwargs)  # noqa: E501
        else:
            (data) = self.post_search_context_find_by_tags_with_http_info(tags, search_context_id, similarity_threshold, max_count, **kwargs)  # noqa: E501
            return data

    def post_search_context_find_by_tags_with_http_info(self, tags, search_context_id, similarity_threshold, max_count, **kwargs):  # noqa: E501
        """Find images by tags. Tags JSON string is passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_search_context_find_by_tags_with_http_info(tags, search_context_id, similarity_threshold, max_count, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tags: Tags array for searching (required)
        :param str search_context_id: The search context identifier. (required)
        :param float similarity_threshold: The similarity threshold. (required)
        :param int max_count: The maximum count. (required)
        :param str folder: The folder.
        :param str storage: The storage.
        :return: SearchResultsSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tags', 'search_context_id', 'similarity_threshold', 'max_count', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_search_context_find_by_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tags' is set
        if ('tags' not in params or
                params['tags'] is None):
            raise ValueError("Missing the required parameter `tags` when calling `post_search_context_find_by_tags`")  # noqa: E501
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `post_search_context_find_by_tags`")  # noqa: E501
        # verify the required parameter 'similarity_threshold' is set
        if ('similarity_threshold' not in params or
                params['similarity_threshold'] is None):
            raise ValueError("Missing the required parameter `similarity_threshold` when calling `post_search_context_find_by_tags`")  # noqa: E501
        # verify the required parameter 'max_count' is set
        if ('max_count' not in params or
                params['max_count'] is None):
            raise ValueError("Missing the required parameter `max_count` when calling `post_search_context_find_by_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'similarity_threshold' in params:
            query_params.append(('similarityThreshold', params['similarity_threshold']))  # noqa: E501
        if 'max_count' in params:
            query_params.append(('maxCount', params['max_count']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'tags' in params:
            form_params.append(('tags', params['tags']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/findByTags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchResultsSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_tiff_append(self, name, append_file, **kwargs):  # noqa: E501
        """Appends existing TIFF image to another existing TIFF image (i.e. merges TIFF images).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_tiff_append(name, append_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Original image file name. (required)
        :param str append_file: Image file name to be appended to original one. (required)
        :param str storage: Your Aspose Cloud Storage name.
        :param str folder: Folder with images to process.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_tiff_append_with_http_info(name, append_file, **kwargs)  # noqa: E501
        else:
            (data) = self.post_tiff_append_with_http_info(name, append_file, **kwargs)  # noqa: E501
            return data

    def post_tiff_append_with_http_info(self, name, append_file, **kwargs):  # noqa: E501
        """Appends existing TIFF image to another existing TIFF image (i.e. merges TIFF images).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_tiff_append_with_http_info(name, append_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Original image file name. (required)
        :param str append_file: Image file name to be appended to original one. (required)
        :param str storage: Your Aspose Cloud Storage name.
        :param str folder: Folder with images to process.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'append_file', 'storage', 'folder']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_tiff_append" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_tiff_append`")  # noqa: E501
        # verify the required parameter 'append_file' is set
        if ('append_file' not in params or
                params['append_file'] is None):
            raise ValueError("Missing the required parameter `append_file` when calling `post_tiff_append`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'append_file' in params:
            query_params.append(('appendFile', params['append_file']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/tiff/{name}/appendTiff', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_search_context_image(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Update image and images features in search context. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_search_context_image(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: Search context identifier. (required)
        :param str image_id: Image identifier. (required)
        :param file image_data: Input image
        :param str folder: Folder.
        :param str storage: Storage
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_search_context_image_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
        else:
            (data) = self.put_search_context_image_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
            return data

    def put_search_context_image_with_http_info(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Update image and images features in search context. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_search_context_image_with_http_info(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: Search context identifier. (required)
        :param str image_id: Image identifier. (required)
        :param file image_data: Input image
        :param str folder: Folder.
        :param str storage: Storage
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'image_id', 'image_data', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_search_context_image" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `put_search_context_image`")  # noqa: E501
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params or
                params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `put_search_context_image`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'image_id' in params:
            query_params.append(('imageId', params['image_id']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/image', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_search_context_image_features(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Update images features in search context. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_search_context_image_features(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str image_id: The image identifier. (required)
        :param file image_data: Input image
        :param str folder: The folder.
        :param str storage: The storage.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_search_context_image_features_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
        else:
            (data) = self.put_search_context_image_features_with_http_info(search_context_id, image_id, **kwargs)  # noqa: E501
            return data

    def put_search_context_image_features_with_http_info(self, search_context_id, image_id, **kwargs):  # noqa: E501
        """Update images features in search context. Image data may be passed as zero-indexed multipart/form-data content or as raw body stream.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_search_context_image_features_with_http_info(search_context_id, image_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search_context_id: The search context identifier. (required)
        :param str image_id: The image identifier. (required)
        :param file image_data: Input image
        :param str folder: The folder.
        :param str storage: The storage.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_context_id', 'image_id', 'image_data', 'folder', 'storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_search_context_image_features" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search_context_id' is set
        if ('search_context_id' not in params or
                params['search_context_id'] is None):
            raise ValueError("Missing the required parameter `search_context_id` when calling `put_search_context_image_features`")  # noqa: E501
        # verify the required parameter 'image_id' is set
        if ('image_id' not in params or
                params['image_id'] is None):
            raise ValueError("Missing the required parameter `image_id` when calling `put_search_context_image_features`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search_context_id' in params:
            path_params['searchContextId'] = params['search_context_id']  # noqa: E501

        query_params = []
        if 'image_id' in params:
            query_params.append(('imageId', params['image_id']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'storage' in params:
            query_params.append(('storage', params['storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image_data' in params:
            local_var_files['imageData'] = params['image_data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/ai/imageSearch/{searchContextId}/features', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def storage_exists(self, storage_name, **kwargs):  # noqa: E501
        """Check if storage exists  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.storage_exists(storage_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str storage_name: Storage name (required)
        :return: StorageExist
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.storage_exists_with_http_info(storage_name, **kwargs)  # noqa: E501
        else:
            (data) = self.storage_exists_with_http_info(storage_name, **kwargs)  # noqa: E501
            return data

    def storage_exists_with_http_info(self, storage_name, **kwargs):  # noqa: E501
        """Check if storage exists  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.storage_exists_with_http_info(storage_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str storage_name: Storage name (required)
        :return: StorageExist
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['storage_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_exists" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'storage_name' is set
        if ('storage_name' not in params or
                params['storage_name'] is None):
            raise ValueError("Missing the required parameter `storage_name` when calling `storage_exists`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'storage_name' in params:
            path_params['storageName'] = params['storage_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/{storageName}/exist', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StorageExist',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_file(self, path, file, **kwargs):  # noqa: E501
        """Upload file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_file(path, file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext             If the content is multipart and path does not contains the file name it tries to get them from filename parameter             from Content-Disposition header.              (required)
        :param file file: File to upload (required)
        :param str storage_name: Storage name
        :return: FilesUploadResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_file_with_http_info(path, file, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_file_with_http_info(path, file, **kwargs)  # noqa: E501
            return data

    def upload_file_with_http_info(self, path, file, **kwargs):  # noqa: E501
        """Upload file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_file_with_http_info(path, file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext             If the content is multipart and path does not contains the file name it tries to get them from filename parameter             from Content-Disposition header.              (required)
        :param file file: File to upload (required)
        :param str storage_name: Storage name
        :return: FilesUploadResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'file', 'storage_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `upload_file`")  # noqa: E501
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `upload_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501

        query_params = []
        if 'storage_name' in params:
            query_params.append(('storageName', params['storage_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['File'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['JWT']  # noqa: E501

        return self.api_client.call_api(
            '/imaging/storage/file/{path}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilesUploadResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    # TODO: investigate auth algorithm
    def request_token(self):
        config = self.api_client.configuration
        request_url = "/connect/token"
        form_params = [('grant_type', 'client_credentials'), ('client_id', config.api_key['app_sid']),
                       ('client_secret', config.api_key['api_key'])]

        header_params = {'Accept': 'application/json', 'Content-Type': 'application/x-www-form-urlencoded'}

        api_version = self.api_client.configuration.api_version
        self.api_client.configuration.api_version = ''

        data = self.api_client.call_api(request_url, 'POST',
                                        {},
                                        [],
                                        header_params,
                                        post_params=form_params,
                                        response_type='object',
                                        files={}, _return_http_data_only=True)
        access_token = data['access_token'] if six.PY3 else data['access_token'].encode('utf8')
        self.api_client.configuration.access_token = access_token

        self.api_client.configuration.api_version = api_version
